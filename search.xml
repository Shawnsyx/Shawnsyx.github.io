<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SC实验四-异常处理</title>
      <link href="/2019/05/09/SC%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2019/05/09/SC%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>&emsp;实验四开始，一点点学习异常处理！<br>&emsp;首先区分异常（Exception）和错误（Error）</p><blockquote><p>The Error class describes internal system errors and resource exhaustion situations inside the Java runtime system (e.g., VirtualMachineError, LinkageError) that rarely occur. </p></blockquote><p>&emsp;内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束 。而对于异常：</p><blockquote><p>The Exception class describes the error caused by your program (e.g. FileNotFoundException, IOException). </p></blockquote><p>&emsp;异常由于自己程序导致的问题，可以捕获、可以处理。<br><strong>Error</strong>举例：User input errors, Device errors, Physical limitations.</p><p>&emsp; 既然Error我们无能为力， 那就转向关注我们能够处理的Exception。</p><hr><h1 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h1><p>Exception分为unchecked和checked两类，分类如下：<br><img src="/images/SC/ExceptionHierarchy.jpg" alt="exceptionHierarchy"><br>程序员可以通过抛出unchecked exception来声明无法解决，不在自己程序处理能力范围内的异常，而checked exception则是用户所期待的，也是需要程序员去处理的。</p><p>如下所示：<br><img src="/images/SC/exceptiontype.jpg" alt="exceptiontype"></p><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="科学记数法表示"><a href="#科学记数法表示" class="headerlink" title="科学记数法表示"></a>科学记数法表示</h3><p>&emsp;根据WZJ老师的建议，可以直接将不符合科学记数法的输入转化为符合要求的数据，也可以<strong>Garbage in, garbage out</strong>般的<strong>Fail Fast</strong>,而我本人选择直接抛出异常信息，并且直接让用户重新操作。</p><p>值得注意的是，在操作过程中，如果try_catch语句中<code>catch(Exception e)</code>,那么无论中间有什么自定义exception都会被覆盖，并且不能输出相关的信息。首先，错误样例如下：<br><img src="/images/exception/1.jpg" alt="exceptiontype"><br>如果在总的构造系统中这样catch异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">  String encoding =<span class="string">"UTF-8"</span>;</span><br><span class="line">  File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">  <span class="keyword">if</span>(file.isFile() &amp;&amp; file.exists()) &#123;  </span><br><span class="line">  ······     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Can't find the file"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则根据文件得到异常信息是这样的：<br><img src="/images/exception/2.jpg" alt="exceptiontype"></p><p>而如果这样写的话<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">      ······</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NotationFormatException e) &#123;</span><br><span class="line">      System.out.println(e.getNumber());</span><br><span class="line">      System.out.println(<span class="string">"请修改按要求文件后重新读入"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"IOE EXCEPTION!!!"</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>则会出现异常的信息：<br><img src="/images/exception/3.jpg" alt="exceptiontype"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 软件构造笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构造笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>口若悬河</title>
      <link href="/2019/04/24/%E5%8F%A3%E8%8B%A5%E6%82%AC%E6%B2%B3/"/>
      <url>/2019/04/24/%E5%8F%A3%E8%8B%A5%E6%82%AC%E6%B2%B3/</url>
      
        <content type="html"><![CDATA[<p>This is for oral English.<br>I’m in desperate need of a notebook but taking down what I’ve learned is way too slow, thus driving me to use this blog as my notebook. (Sometimes a diary)</p><hr>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SC实验三</title>
      <link href="/2019/04/16/SC%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2019/04/16/SC%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>&emsp;该实验面向可复用性进行设计，需要学习掌握一定的设计模式针对不同的应用进行设计。而我本人选择的三个应用：StellarSystem（太阳系恒星模型）、AtomStructure（原子结构模型）、SocialNetworkCircle（社交网络）。</p><hr><h2 id="可复用啊！！！-L-E。"><a href="#可复用啊！！！-L-E。" class="headerlink" title=" 可复用啊！！！ L,E。 "></a> 可复用啊！！！ L,E。 </h2><h1 id="不同对象的面向复用的设计-Reusability"><a href="#不同对象的面向复用的设计-Reusability" class="headerlink" title="不同对象的面向复用的设计(Reusability)"></a>不同对象的面向复用的设计(Reusability)</h1><h2 id="CircularOrbit-lt-L-E-gt"><a href="#CircularOrbit-lt-L-E-gt" class="headerlink" title="CircularOrbit&lt;L,E&gt;"></a>CircularOrbit&lt;L,E&gt;</h2><p>&emsp;<strong>Mutable</strong>的类型。<br>&emsp;设计新的接口CircularOrbit&lt;L,E&gt;,其中L和E分别代表多轨道系统的中心点物体和轨道物体。可有的操作：</p><ul><li>创建一个空的 CircularOrbit 对象</li><li>增加一条轨道、去除一条轨道 </li><li>增加中心点物体</li><li>向特定轨道上增加一个物体（不考虑物理位置） </li><li>增加中心点物体和一个轨道物体之间的关系 </li><li>增加两个轨道物体之间的关系 </li><li>从外部文件读取数据构造轨道系统对象 </li></ul><h2 id="Track"><a href="#Track" class="headerlink" title="Track"></a>Track</h2><p>&emsp;<strong>Immutable</strong>的ADT。<br>&emsp;需要设计rep：1.半径</p><h2 id="L（CircularOrbit-lt-L-E-gt-中的L）"><a href="#L（CircularOrbit-lt-L-E-gt-中的L）" class="headerlink" title="L（CircularOrbit&lt;L,E&gt;中的L）"></a>L（CircularOrbit&lt;L,E&gt;中的L）</h2><p>&emsp;所设计的表征中心点物体的类。</p><ul><li>StellarSystem：中心点物体为恒星 </li><li>AtomStructure：中心点物体为原子核 </li><li>SocialNetworkCircle：中心点物体为人 </li></ul><h2 id="PhysicalObject"><a href="#PhysicalObject" class="headerlink" title="PhysicalObject"></a>PhysicalObject</h2><p>&emsp;<strong>Immutable的</strong>ADT。<br>&emsp;实现 ConcreteCircularOrbit&lt;L,E&gt;中的 E，即代表分布在不同轨道上的物 体类 PhysicalObject。可以是接口，也可以是抽象类。 考虑到不同应用中包含不同类型的轨道物体，需从 PhysicalObject 派生子 类型，通过 override 实现 PhysicalObject 中的各个接口方法或抽象方法，也可 根据应用需求来增加子类的特有属性和方法。</p><ul><li>StellarSystem：轨道物体为行星 </li><li>AtomStructure：轨道物体为电子 </li><li>SocialNetworkCircle：轨道物体为人</li></ul><h2 id="可复用的API设计"><a href="#可复用的API设计" class="headerlink" title="可复用的API设计"></a>可复用的API设计</h2><p>&emsp;API-Application Programming Interface. 何为API→<a href="https://blog.csdn.net/cumtdeyurenjie/article/details/80211896" target="_blank" rel="noopener">点此了解</a>。</p><ul><li>计算多轨道系统中各轨道上物体分布的熵值。<br>&emsp;<code>double getObjectDistributionEntropy(CircularOrbit c)</code></li><li>计算任意两个物体之间的最短逻辑距离。<br>&emsp;<code>int getLogicalDistance (CircularOrbit c, E e1, E e2)</code>若两物体无联系，距离无穷大。（Lab1中P3已实现该功能）</li><li>计算任意两个物体之间的物理距离。（若有具体位置，可在直角坐标系中计算）<br>&emsp;<code>double getPhysicalDistance (CircularOrbit c, E e1, E e2)</code></li><li>//TODO 计算两个多轨道系统之间的差异</li></ul><h2 id="第三方API复用"><a href="#第三方API复用" class="headerlink" title="第三方API复用"></a>第三方API复用</h2><p>&emsp;实现可视化</p><h2 id="设计模式应用"><a href="#设计模式应用" class="headerlink" title="设计模式应用"></a>设计模式应用</h2><p>(1) 构造 Track、PhysicalObject 等对象时，请使用 <strong>factory method</strong> 设计模式。<br>(2) 构造 ConcreteCircularOrbit 对象时，针对不同应用中所需的不同类型的 L 和 E，使用 <strong>abstract factory</strong> 或 <strong>builder</strong> 设计模式。<br>(3) <strong>Iterator</strong>设计模式,在遍历各PhysicalObject对象时使用。<br>(4) 可复用API时遵循<strong>façade</strong> 设计模式，将所有 API 放置在 helper类CircularOrbitAPIs当中<br>(5) StellarSystem 应用中使用<strong>decorator</strong>设计模式<br>(6) AtomStructure 应用中，请使用 <strong>state</strong> 和 <strong>memento</strong> 设计模式管理电子跃迁 的状态，并可进行状态的恢复。意即：可保存电子每次跃迁前后的轨道信息。</p><hr><h1 id="实验涉及知识"><a href="#实验涉及知识" class="headerlink" title="实验涉及知识"></a>实验涉及知识</h1><h2 id="继承和委托"><a href="#继承和委托" class="headerlink" title="继承和委托"></a>继承和委托</h2><p>&emsp;继承inheritance.可能涉及到override,较易理解。下面重点分析delegation（委托）<br>简而言之，delegation是一个对象需要依赖其他的对象所实现功能的行为。<br>&emsp;分为Explicit和Implicit两种。<br>&emsp;-e.g. the<code>Sorter</code> is delegating functionality to some <code>Comparator</code></p><h2 id="LSP-Liskov替换原则）"><a href="#LSP-Liskov替换原则）" class="headerlink" title="LSP(Liskov替换原则）"></a>LSP(Liskov替换原则）</h2><ul><li>Subtypes can add, but not remove methods<br>&emsp;子类型可以增加方法，但不可删。</li><li>Concrete class must implement all undefined methods<br>&emsp;子类型需要实现抽象类型中的所有未实现方法。</li><li>Overriding method must return same type or subtype<br>&emsp;子类型中重写的方法必须有相同或子类型的返回值。</li><li>Overriding method must accept the same parameter types<br>&emsp;子类型中重写的方法必须使用同样类型的参数。</li><li>Overriding method may not throw additional exceptions<br>&emsp;子类型中重写的方法不能抛出额外的异常。<br><strong>而且满足下列条件</strong>：</li><li>Same or stronger invariants 更强的不变量</li><li>Same or weaker preconditions 更弱的前置条件</li><li>Same or stronger postconditions 更强的后置条件</li></ul><p><img src="/images/SC/LSP.jpg" alt="liskov"></p><h2 id="抽象类？"><a href="#抽象类？" class="headerlink" title="抽象类？"></a>抽象类？</h2><p>&emsp;抽象类与多态有关，了解抽象类-&gt;<a href="https://www.cnblogs.com/pssp/p/6296677.html" target="_blank" rel="noopener">为什么使用抽象类？</a></p><h2 id="OO-Design-Principles-SOLID"><a href="#OO-Design-Principles-SOLID" class="headerlink" title="OO Design Principles:SOLID"></a>OO Design Principles:SOLID</h2><ul><li>(SRP)  The Single Responsibility Principle 单一责任原则 </li><li>(OCP) The Open-Closed Principle 开放-封闭原则</li><li>(LSP)  The Liskov Substitution Principle Liskov替换原则 </li><li>(DIP)  The Dependency Inversion Principle 依赖转置原则 </li><li>(ISP)   The Interface Segregation Principle 接口聚合原则</li></ul><h3 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h3><p>一个类，一个责任。（下图为反例）<br><img src="/images/SC/SRP.jpg" alt="srp"></p><h3 id="OCP"><a href="#OCP" class="headerlink" title="OCP"></a>OCP</h3><p><strong>对扩展性的开放，对修改的封闭。</strong></p><ul><li>模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化</li><li>但模块自身的代码是不应被修改的</li><li>扩展模块行为的一般途径是修改模块的内部实现</li><li>如果一个模块不能被修改，那么它通常被认为是具有固定的行为</li></ul><p>&emsp;关键技术:<strong>抽象</strong></p><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>前文</p><h3 id="ISP-接口隔离"><a href="#ISP-接口隔离" class="headerlink" title="ISP 接口隔离"></a>ISP 接口隔离</h3><p>不能强迫客户端依赖于它们 不需要的接口：只提供必需的接口<br><img src="/images/SC/ISP.jpg" alt="isp"></p><h3 id="DIP-依赖转置"><a href="#DIP-依赖转置" class="headerlink" title="DIP 依赖转置"></a>DIP 依赖转置</h3><ul><li>抽象的模块不应依赖于具体的模块</li><li>具体应依赖于抽象</li></ul><p><img src="/images/SC/DIP.jpg" alt="dip"><br>&emsp;关键词:<strong>隔离</strong></p><hr><h1 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h1><p>一览Design Patterns的框架<br><img src="/images/SC/design.jpg" alt="design patterns"></p><h2 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h2><p>&emsp;为什么要这种模式：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。<br>&emsp;<strong>Problem:</strong>如何为对象增加不同侧面的特性。<br>&emsp;<strong>Solution:</strong>对每一个特性构造子类，通过委派机制增加到对象上。<br><img src="/images/SC/decorator.jpg" alt="decorator"><br>&emsp;- 抽象构件类（Component）：给出一个抽象的接口，用以规范准备接收附加责任的对象<br>&emsp;- 具体构件类（ConcreteComponent）：定义一个具体的准备接受附加责任的类，其必须实现Component接口。<br>&emsp;- 装饰者类（Decorator）：有一个构件（Conponent）对象的成员变量，并定义一个和抽象构件一致的接口（我们就是通过这个一致的接口中的东西来加东西）。<br>&emsp;- 具体装饰者类（Concrete Decoratator）：定义给构件对象“贴上”附加责任。<br>&emsp;每次想给具体构建类的某个实例加上一点东西的时候，我们做出要加上的东西对应的具体装饰者类，以具体构建类作为构造器的输入参数，然后调用装饰类的方法输出装饰后的结果。注意上述所有的变量的声明都是他们的公共接口。<br>看<a href="https://blog.csdn.net/ma598214297/article/details/80699377" target="_blank" rel="noopener">decorator模式</a>.其中关键的decorator为material里面添加的内容。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Material</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beef</span><span class="params">(Noodle noodle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(noodle);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescriptin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noodle.getDescriptin()+<span class="string">" + 牛肉"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> noodle.cost()+<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="facade（外观模式）"><a href="#facade（外观模式）" class="headerlink" title="facade（外观模式）"></a>facade（外观模式）</h2><p>&emsp;外观模式是为了解决类与类之间的依赖关系的，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。<br>&emsp;应用于小的接口，目的是提供<strong>一个</strong>进行相似工作的接口。详细理解<a href="https://www.jianshu.com/p/f28d71ee46e7" target="_blank" rel="noopener">外观模式</a><br>例如：<br><img src="/images/SC/facade.jpg" alt="facade"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemA</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationA</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"operation a..."</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemB</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationB</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"operation b..."</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemC</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationC</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"operation c..."</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>facade</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapOperation</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        SystemA a = <span class="keyword">new</span> SystemA(); </span><br><span class="line">        a.operationA(); </span><br><span class="line">        SystemB b = <span class="keyword">new</span> SystemB(); </span><br><span class="line">        b.operationB(); </span><br><span class="line">        SystemC c = <span class="keyword">new</span> SystemC(); </span><br><span class="line">        c.operationC(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade(); </span><br><span class="line">        facade.wrapOperation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="strategy模式"><a href="#strategy模式" class="headerlink" title="strategy模式"></a>strategy模式</h2><ul><li>问题描述：对于一个特定问题存在不同的算法，客户能够在动态运行期间(at run time)在这些算法之间切换。</li><li>e.g. Sorting a list of customers(bubble sort, mergesort, quicksort)</li><li>解决： 创造一个接口，对算法中每个variant创建一个实现类。(implementing class)</li></ul><p><img src="/images/SC/strategy.jpg" alt="strategy"></p><h2 id="state模式"><a href="#state模式" class="headerlink" title="state模式"></a>state模式</h2><p>&emsp;用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。<br>状态模式所涉及到的角色:</p><ul><li>环境(Context)角色，也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。</li><li>抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。</li><li>具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。</li></ul><p><img src="/images/SC/state.jpg" alt="state"><br>详细阅读→<a href="https://www.cnblogs.com/betterboyz/p/9378068.html" target="_blank" rel="noopener">状态模式</a></p><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul><li>问题所在：客户需要访问容器内的所有元素，无论该容器的类型如何</li><li>解决方案：A strategy pattern for iteration</li><li>应用场景：(1)访问一个聚合对象而不需暴露对象内部表示；(2)支持对聚合对象的多种遍历；(3)对遍历不同的对象，提供统一的接口。<br><img src="/images/SC/iterator.jpg" alt="iterator"><br>具体示例<a href="https://www.cnblogs.com/xing901022/p/4079722.html" target="_blank" rel="noopener">iterator迭代器设计模式</a>和<a href="https://www.cnblogs.com/kingofkai/p/5836562.html" target="_blank" rel="noopener">迭代器模式</a></li></ul><h2 id="Factory-Method-pattern"><a href="#Factory-Method-pattern" class="headerlink" title="Factory Method pattern"></a>Factory Method pattern</h2><p>Also known as “Virtual Constructor”. <a href="https://www.cnblogs.com/Bobby0322/p/4179921.html" target="_blank" rel="noopener">工厂方法案例1</a>和<a href="http://c.biancheng.net/view/1348.html" target="_blank" rel="noopener">工厂方法案例2</a><br>&emsp;应用场景：当client不知道要创建哪个具体类的实例，或者不想在client代码中指明要具体 创建的实例时，用工厂方法。 定义一个用于创建对象的接口，让其子类来决定实例化哪一个类，从而使一个类的实例化延迟到其子类。<br><img src="/images/SC/FM.jpg" alt="Factory method"></p><ul><li>抽象产品角色（Product）：定义产品的接口</li><li>具体产品角色（ConcreteProduct） ：实现接口Product的具体产品类</li><li>抽象工厂角色（Creator） ：声明工厂方法（FactoryMethod），返回一个产品</li><li>真实的工厂（ConcreteCreator）：实现FactoryMethod工厂方法，由客户调用，返回一个产品的实例</li></ul><p>&emsp;开工厂方法就是不想把子类名字暴露，把创建和返回隔离开。在子类实现过程当中不会暴露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Track <span class="title">getTrack</span><span class="params">(<span class="keyword">int</span> inputRadius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SocialTrack(inputRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h2><p>&emsp; 创建的不是一个完整产品，而是“产品族”（遵循 固定搭配规则的多类产品的实例），得到的结果是：多个不同产品的 object，各产品创建过程对client可见，但“搭配”不能改变。<br>&emsp; 本质上，Abstract Factory是把多类产品的factory method组合在一起<br><img src="/images/SC/FM.jpg" alt="fm"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;  <span class="comment">// A产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;  <span class="comment">// B产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstracFactory</span> </span>&#123;  <span class="comment">// 产品族的抽象工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ProductA1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product B1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product A2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product B2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">extends</span> <span class="title">AbstracFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Factory1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Factory1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">extends</span> <span class="title">AbstracFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Factory2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Factory2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">        AbstracFactory FAC;</span><br><span class="line">        AbstractProductA PA;</span><br><span class="line">        AbstractProductB PB;</span><br><span class="line"></span><br><span class="line">        FAC = <span class="keyword">new</span> Factory1();</span><br><span class="line">        PA = FAC.createProductA();</span><br><span class="line">        PA.productMethod();</span><br><span class="line">        PB = FAC.createProductB();</span><br><span class="line">        PB.productMethod();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line">        FAC = <span class="keyword">new</span> Factory2();</span><br><span class="line">        PA = FAC.createProductA();</span><br><span class="line">        PA.productMethod();</span><br><span class="line">        PB = FAC.createProductB();</span><br><span class="line">        PB.productMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="builder"><a href="#builder" class="headerlink" title="builder"></a>builder</h2><p><img src="/images/SC/builder.jpg" alt="builder"></p><ul><li>Builder: 为创建一个Product对象的各个部件指定抽象接口。</li><li>ConcreteBuilder: 实现Builder的接口以构造和装配该产品的各个部件;定义并明确它所创建的表示;提供一个获取产品的接口。</li><li>Director: 构造一个使用Builder接口的对象。</li><li>Product: 表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程 。包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li></ul><p>&emsp;举例：去必胜客点pizza。服务员(director)推荐给你套餐(builder),套餐一：甜甜圈，辣酱和海鲜披萨（concretebuilder），套餐二：薯条，番茄酱和水果披萨（concretebuilder）……而具体的套餐内产品（product）要进行制作（构造）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String sauce;</span><br><span class="line"><span class="keyword">private</span> String siders;</span><br><span class="line"><span class="keyword">private</span> String pizza;</span><br></pre></td></tr></table></figure><p>配上一系列set操作，叮，做好了！</p><h2 id="memento-备忘录模式）"><a href="#memento-备忘录模式）" class="headerlink" title="memento(备忘录模式）"></a>memento(备忘录模式）</h2><p><a href="https://www.cnblogs.com/gaochundong/p/design_pattern_memento.html" target="_blank" rel="noopener">设计模式之美：备忘录模式</a>和<a href="https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html" target="_blank" rel="noopener">《java与模式》备忘录模式</a><br>&emsp;意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<br>&emsp;结构：<br><img src="/images/SC/memento.jpg" alt="memento"><br><a href="https://1170300229.github.io/2019/03/31/scLab3/" target="_blank" rel="noopener">橙子说</a>：</p><blockquote><p>Originator发起人角色：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据<br>Memento备忘录角色：负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。<br>Caretaker备忘录管理员角色：对备忘录进行管理、保存和提供备忘录。</p></blockquote><h1 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h1><h2 id="Track-1"><a href="#Track-1" class="headerlink" title="Track"></a>Track</h2><p>&emsp;构造当中用极复杂的方式实现本来很简单的数据结构。但是便于扩展应用。（后来想想我就是傻，一个Track有啥扩展的？）<br>&emsp;</p><hr><h2 id="test测试小插曲"><a href="#test测试小插曲" class="headerlink" title="test测试小插曲"></a>test测试小插曲</h2><p>assertEquals对double类型测试出错?<br><img src="/images/SC/e1.jpg" alt="e1"><br>&emsp;查阅资料-看异常中的提醒<strong>Use assertEquals(expected, actual, delta) to compare floating-point numbers</strong>, 即按照“预期值，真实值，误差值”的格式，只要在这个范围内就算正确。<br>&emsp;后来改成这个<code>assertEquals( 2.2, stellarTrack.getRadius(),0.0);</code></p><hr><h2 id="科学记数法处理"><a href="#科学记数法处理" class="headerlink" title="科学记数法处理"></a>科学记数法处理</h2><p>&emsp;在实验中涉及到对number的处理</p><blockquote><p>大于 10000 的数字按科学记数法表示（例如 1.9885e30 表示1.9885 ∗ 1030，但 e 之前数字的整数部分必 须在 1 到 9 的范围内，e 之后的数字只能是大于 3 的正整 数），小于 10000 的数字直接给出（例如 5912，103.193）， 不能用科学计数法。小数点位数不限制。</p></blockquote><p>以本人设计的Stellar（恒星系的中心物体）为例，域如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br></pre></td></tr></table></figure><p>如何根据要求转化为double类型的呢？橙子又说，BigDecimal！<br><code>this.radius = new BigDecimal(inputRadius).doubleValue(); //转化为科学记数法</code></p><hr><h2 id="为什么轨道上放不了物体？"><a href="#为什么轨道上放不了物体？" class="headerlink" title="为什么轨道上放不了物体？"></a>为什么轨道上放不了物体？</h2><p>发现如果直接用<code>placeObject（Track inputtrack, E object)</code>就直接能加上物体，而如果先加入轨道的话就不能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">placeObject</span><span class="params">(Track t, E object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tracks.contains(t) &amp;&amp; objectsOnTrack.containsKey(t)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(objectsOnTrack.get(t).contains(object)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"The object has been on that Track"</span>);  <span class="comment">//如果物体已在轨道，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      objectsOnTrack.get(t).add(object);  <span class="comment">//轨道在集合中，但物体不在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;                        <span class="comment">//加入物体的信息，返回成功加入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!tracks.contains(t)) &#123;   <span class="comment">//轨道不含有t</span></span><br><span class="line">      tracks.add(t);</span><br><span class="line">      List&lt;E&gt; objects = <span class="keyword">new</span> ArrayList&lt;E&gt;();  <span class="comment">//创建轨道上一组物体</span></span><br><span class="line">      objects.add(object);  </span><br><span class="line">      objectsOnTrack.put(t, objects);     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    else if(objectsOnTrack.containsKey(t)) &#123;</span></span><br><span class="line"><span class="comment">//      objectsOnTrack.get(t).add(object);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>关键在于我的addTrack：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addTrack</span><span class="params">(Track inputTrack)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tracks.contains(inputTrack)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"The track has been there."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  tracks.add(inputTrack);   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//轨道与物体对应关系上，建立新集合，放入匹配。</span></span><br><span class="line">  List&lt;E&gt; objects = <span class="keyword">new</span> ArrayList&lt;E&gt;();</span><br><span class="line">  objectsOnTrack.put(inputTrack, objects);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;第一开始并没有在<code>objectsOnTrack.put(inputTrack, objects);</code>和<code>List&lt;E&gt; objects = new ArrayList&lt;E&gt;();</code>,如果不事先放入一个集合进objectsOnTrack这个map的话，会返回空指针。</p><hr><h2 id="子类成员变量和父类"><a href="#子类成员变量和父类" class="headerlink" title="子类成员变量和父类"></a>子类成员变量和父类</h2><p>在我的SocialNetworkCircle和其父类ConcreteCircularOrbit中都有<br><code>private final List&lt;Track&gt; tracks;   //人际关系，其中radius表示好友所在的轨道级数</code><br>&emsp;然而我在子类方法中调用父类的placeObject，其中会加入新轨道。父类<code>placeObject</code>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">placeObject</span><span class="params">(Track t, E object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tracks.contains(t) &amp;&amp; objectsOnTrack.containsKey(t)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(objectsOnTrack.get(t).contains(object)) &#123;</span><br><span class="line">      System.out.println(<span class="string">"The object has been on that Track"</span>);  <span class="comment">//如果物体已在轨道，返回false</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objectsOnTrack.get(t).add(object);  <span class="comment">//轨道在集合中，但物体不在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;                        <span class="comment">//加入物体的信息，返回成功加入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!tracks.contains(t)) &#123;   <span class="comment">//轨道不含有t</span></span><br><span class="line">    tracks.add(t);</span><br><span class="line">    </span><br><span class="line">    System.out.println(tracks.size());</span><br><span class="line">    List&lt;E&gt; objects = <span class="keyword">new</span> ArrayList&lt;E&gt;();  <span class="comment">//创建轨道上一组物体</span></span><br><span class="line">    objects.add(object);  </span><br><span class="line">    objectsOnTrack.put(t, objects);     </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>给的样例中，和中心人物有关的有四对关系，但其中只有两级轨道。一级好友和两级好友。<br>子类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Track t = <span class="keyword">new</span> SocialTrackFactory().getTrack(String.valueOf(distance));</span><br><span class="line">tracks.add(t);    <span class="comment">//不然的话无法成功加入</span></span><br><span class="line">placeObject(t, p1);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//关系可能为负数，无限大，此时不加入。</span></span><br></pre></td></tr></table></figure><p>&emsp;第<strong>3</strong>行为关键，如果注释掉的话每次都会new一个新的track，但是如果加上，只会new两个。猜测这个加入到父类的tracks中而非子类的。<br>&emsp;证据：<br><img src="/images/SC/tracks.jpg" alt="tracks"></p><p>后来发现objectsOnTrack这个map也有问题，同样的操作会直接对父类的这个成员变量产生影响，唉，索性让我重写父类的方法再ctrl +c/+v。</p><p>&emsp;<strong>续：</strong>后来得知我的子类的重复定义了父类的成员变量，然后调用一系列方法的时候会被父类成员变量覆盖。</p><h2 id="保留两位小数"><a href="#保留两位小数" class="headerlink" title="保留两位小数"></a>保留两位小数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal rounded = <span class="keyword">new</span> BigDecimal(entropy);</span><br><span class="line"><span class="keyword">double</span> entropyRounded = rounded.setScale(<span class="number">2</span>, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br></pre></td></tr></table></figure><p>  其中<code>entrop</code>是计算熵的时候用的。</p><h2 id="何方异常是也？ConcurrentModificationException？"><a href="#何方异常是也？ConcurrentModificationException？" class="headerlink" title="何方异常是也？ConcurrentModificationException？"></a>何方异常是也？ConcurrentModificationException？</h2><p>在写星体转动的时候，在position中进行了这样的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Planet p : position.keySet()) &#123;</span><br><span class="line">  ······</span><br><span class="line">  position.remove(p);</span><br><span class="line">  position.put(p, sitha);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  就会报错。</p><h2 id="表示暴露实例分析"><a href="#表示暴露实例分析" class="headerlink" title="表示暴露实例分析"></a>表示暴露实例分析</h2><p>&emsp;纪念第一次通宵写程序。在获取轨道变化前的map时我的画风</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Track track : objectsOnTrack.keySet()) &#123;</span><br><span class="line">  memento.put(track,objectsOnTrack.get(track));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;想着直接把List<electron>塞进去了，但是后续清空objectsOnTrack的时候“似乎new”出来的这个memento（map类型）也会如影随形般变化，所以一定暴漏了。</electron></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Track track : objectsOnTrack.keySet()) &#123;</span><br><span class="line">  List&lt;Electron&gt; e1 = <span class="keyword">new</span> ArrayList&lt;Electron&gt;();</span><br><span class="line">  <span class="keyword">for</span>(Electron e : objectsOnTrack.get(track)) &#123;</span><br><span class="line">    e1.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  memento.put(track,e1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;如此安好！</p><hr><p>&emsp;实验三算过去了，总结的也算一般般吧。一点点进步吧，加油！</p>]]></content>
      
      
      <categories>
          
          <category> 软件构造笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构造笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夜里春秋</title>
      <link href="/2019/04/13/%E5%A4%9C%E9%87%8C%E6%98%A5%E7%A7%8B/"/>
      <url>/2019/04/13/%E5%A4%9C%E9%87%8C%E6%98%A5%E7%A7%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>于是我剪下了月光</em><br><em>射向我老家的地方</em></p></blockquote><p>&emsp;郑州的夜比哈尔滨多了活力与隐隐的躁动，比北京的夜多了些魅惑和妩媚，比商丘多了些大气。</p><p>&emsp;如今，郑州的星星也多了些，大抵是空气得到改善了吧。</p><p>&emsp;我随着颠颠簸簸的机场大巴晃着脑袋，感到4月份的郑州俨然一副夏季整装待发的样子。左座扎着马尾辫的女子低着头刷着抖音，时不时掸去吃在身上的饼干屑；后座一对从哈尔滨回来的男生对着同行女伴绘声绘色地描述着自己的风光往事；隔着过道年轻妈妈的右臂侧枕着约莫2岁的熟睡的儿子，她偶尔也瞥了头地向窗外看去，看这绿城路灯与树影的光影交错。除了随车摇晃的频率，一车的人，无一处相似。</p><p>&emsp;星光与灯光似是漫长黑夜展开中的点点白亮。夜景难忘，难忘的事与深情的回忆都在夜里浮现。</p><p>&emsp;18年夏天，大一暑假宅在北京不亦乐乎。除了夜里跑到对面北京体育大学操场里与大爷大妈们一起跑步，几乎没出过门。</p><p>&emsp;17年夏天，刚刚走出考场就被堂哥开车一路送往商丘高铁站，赶上去往北京的夜班车。爸一路同行，偶尔预测几句我的高考成绩并开始了对我未来教育事业的分析。上了高铁，我则和爸一路默契地枕着高铁的座位默不作声开始了孙家的“休养生息”。爸两年陪读的辛酸不亚于我一路走来的心力交瘁，而现在我终于开始慢慢领悟到于两年中一声不吭地忍耐坏脾气的屁孩儿是一件多么伟大的事。到了北京，姐夫早已叫好了午夜出租。到家凌晨，一身臭汗，一脸痘坑。再来就是我第二天早晨无精打采地听北京出租车司机儿化音碎碎念：“我儿子比你小点儿，今年高中，嘿，这孩儿不争气，中考时都能睡迷糊过头儿……”。那年夏天回龙观依然那么村儿，地铁旁的公交站牌也没有遮阳棚，害得我又黑了几个度。13号线依然那么挤，脚不离地上地铁让人记忆犹新。不过，中央民族大学对面的酸豆角炒饭还是不错的。17年夏天，同学之间流行起了手机狼人杀，我常常光膀子坐在阳台马扎上边洒着杨梅须上的水，边与他们来场“最心机奖”的角逐。</p><p>&emsp;17年夏季的一天夜晚回了老家，重见了发小，那是一个被他们先礼后兵（寒暄加温暖）用啤酒灌晕的夜。17年昏黄交错的夏夜不过是平常的，依然有着老爹四季梅配孜然粉的充满油烟味的夜。</p><p>&emsp;15，16的夜没什么波澜曲折，偶尔穿插生活中的起伏，每夜同样的困乏无力，每夜同样的如山作业，每夜不同的习题和每夜桌前不同的洗好的水果。最怀念那11：00左右一重一轻的上楼声和夹杂着的咳嗽，那是爸回来前的序曲。伴随着对着防盗门插钥匙咯嚓咯嚓的响声，他掂着菜和水果零食回来了。</p><p>&emsp;“为啥这么晚？”我用近乎审讯的语气问。</p><p>&emsp;“打了会儿扑克。”他一脸无奈和“一副小屁孩儿别管老子”的不屑。偶尔他会不那么敷衍地回上“今天斗了会儿地主，赢点小钱儿，买了你爱吃的烧牛肉。” 爸在夜里不那么健谈，总能玩着手机玩着玩着耷拉下头打起呼噜。最怀念周六模考后的夜，他会按时按点地接满一澡池的温水，等我回来大快朵颐后再来场水浴洗礼。夜里会在桌前听见回家路过的三少唱着“我就是我”，不同的曲目代表不同的心情。SYQ则必挎一墨绿色水壶一步一步地回到中行家属院，在门前刷卡或等着别人刷卡。这样看来，中学的夜也不过是平常的充斥生活琐屑的夜。</p><p>&emsp;儿时的夜却是最幻炫的夜。发小（壮哥、HW、LDX）和我干了很多没心没肺的事儿。我们曾找来砖头和废纸，堆成小炉灶开始烧，看谁的黑烟又高又胖，然后看谁在被环卫大妈追打时跑的最快。也曾在建筑楼房的沙堆上挖出一个又一个大坑，看谁的陷阱总不容易被发现，一次我曾经往一个坑里撒泡尿，却自己踩了雷，至此退出挖坑联盟。还曾在夜里在家属院玩捉迷藏，捉到最后就剩我一个傻了吧唧地被野狗追着跑。儿时偶尔会半夜醒来，看堂屋亮着的灯和空空如也的屋子，我就知道爸妈开始了建军大业——深夜麻将场。</p><p>&emsp;09年的中秋节夜里，月亮很亮很大，爸送我和妈去武汉找我姐，正值国庆的商丘有些微凉，我却傻不愣登带了一堆毛衣去武汉热成智障。没有常识不学无术的我不知道长江水变质有多快，离开武汉前我去长江大桥下盛满了一绿茶瓶子的长江水，回到老家打开瓶盖时那“沁人心脾”致人于死地的臭味让我终生难忘。夜里有一次写检讨的时候还舞文弄墨地以“人生如梦，一尊还酹江月”为开头，自以为文采飞扬的检讨书现在重读不过是一地鸡毛，还是土鸡的毛。</p><p>&emsp;08年的夜，奥运会和篇篇被迫写日记的夜，被蚊子咬的夜，还有那随着爸去郊外申甘林带一同捉知了，然后被手电筒照见的孤坟吓得半死的夜。据我妈回忆，我在当时就表现出了“懂得心疼人”的特点，会在夜里11点就催着我爸回去以防第二天休息不好影响上班。可是后来想想，可能是由于我的勇气值用完了急需回家冷静的缘故。</p><p>&emsp;今年冬季的夜，爸回忆，在我两岁的一个夜里，他喝醉回家后看见我在胡同门口雪堆前等着他回来。一激动没抱起来我，却直接对我来个泰山压顶。</p><p>&emsp;“你还记得吗？”他强忍笑意地问。</p><p>&emsp;“不记得，好像不记得小伙伴们咋看我笑话，也不记得如何扑棱手脚也翻不过你压着我的身子。”</p><p>&emsp;小时候不觉得夜有多美多温馨，太过寻常太过平凡了。我会和姐在傍晚夜幕降临前一人两个桌角地把饭桌抬出厨房，然后边尝着爸炒的空心菜，土豆肉丝，焖虾，边端着汤、碗小心翼翼地挪着脚。</p><p>&emsp;小时候小胆儿，最期望睡前能听到爸的呼噜声而非妈讲童话。因为爸的呼噜声总让我觉得这世界上的鬼肯定会先通过声音找我爸，然后放过我。或者早被我爸的呼噜声烦死，然后不来。<br>长大了，好像不大做噩梦了，也开始觉得爸的呼噜声吵人了，为此还不少在郑州嫌弃我爸，觉得门的隔音效果太差，恨不得在各个漏音的孔里灌满水泥封得严严实实。</p><p>&emsp;后来离开家，想听爸的呼噜声也听不到了。</p><p>&emsp;没在郑州看见过黄河，只在哈尔滨看到过松花江，岸边五光十色的霓虹和对岸萧条无灯火的太阳岛对比鲜明。从防洪纪念塔望去，正好看到浮出水面的沙渚。偶尔晴朗的天，会给皎月登场的机会，却都免不了那“江月年年望相似”的重复感。</p><p>&emsp;大巴依旧颠簸，生活依然继续，心依然疲惫。<br>&emsp;那些个再也回不去的夜，再也无法回头的路。</p><p>&emsp;我想我爸了。</p><blockquote><p><em>爱恨是掌心的沙漠</em><br><em>故事被点了穴遗忘</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竹林深处 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>English_3.30</title>
      <link href="/2019/03/30/English-3-30/"/>
      <url>/2019/03/30/English-3-30/</url>
      
        <content type="html"><![CDATA[<p>&emsp;第一篇英语笔记，道阻且长。</p><p>&emsp;错的最多的就是每篇的压轴题：6选3，几乎没有全对过，哎呀我的心呀。</p><h1 id="TPO-11-Reading"><a href="#TPO-11-Reading" class="headerlink" title="TPO 11 Reading"></a>TPO 11 Reading</h1><hr><h2 id="Ancient-Egyptian-Sculpture"><a href="#Ancient-Egyptian-Sculpture" class="headerlink" title="Ancient Egyptian Sculpture"></a>Ancient Egyptian Sculpture</h2><p>&emsp;大体讲了埃及建筑物的特点，新词<strong>frontality</strong>，无论材质如何（stone，wooden or metal），都体现这个“正面性”，展示雕塑的姿态。在此基础上探讨了雕塑decorative作用等等……</p><p>&emsp;错题2，事实信息题,根据提问，应该从段落的文句中寻找答案，冒号之后罗列雕塑不受欢迎的原因。</p><blockquote><p>Why did the Egyptians not develop sculpture in which the body turned and twisted through space like classical Greek statuary? </p></blockquote><p>&emsp;错题14：两个错的选项要根据原文找矛盾，关键地方是功能性评价，重要性等方面，以及性质的对比。</p><p>词汇方面：<em>divine pillared（pillar）deity elite depicts</em></p><hr><h2 id="Orientation-and-Navigation"><a href="#Orientation-and-Navigation" class="headerlink" title="Orientation and Navigation"></a>Orientation and Navigation</h2><p>&emsp;讲了鸟类定位，主要行文方式：罗列一系列的实验并穿插猜测和结论。第一段提出问题以及引出主要的实验研究人员Gustave Kramer</p><p>&emsp;错题25：组织结构题，可知本文应该利用一系列实验去证明“鸟儿在日间和夜间的定位方法”<br><del>A structured argument about the importance of internal versus external cues for navigation is presented</del><br>而是：A number of experiments are described to support the idea that birds use the Sun and the night sky to navigate.</p><p>&emsp;错题28[概要小结]:错因：信息矛盾-没有关注原文“一系列”实验与题中阐述的”in one set”矛盾。</p><p>词汇方面：<em>flutter overcast surmise preposterous(荒谬的) versus(prep.与之相对)</em></p><hr><h2 id="Begging-by-Nestlings"><a href="#Begging-by-Nestlings" class="headerlink" title="Begging by Nestlings"></a>Begging by Nestlings</h2><p>一言蔽之：鸟儿叫 = 爸妈给食 + predators</p><p>&emsp;错题37[事实信息题]:根据关键词定位相关段落（第四段)+排除法</p><p>&emsp;错题42[概要小结题]:随缘吧</p><p>词汇方面：<em>conceal</em></p><p>难句理解</p><blockquote><p>The hypothesis that begging calls have evolved properties that reduce their potential for attracting predators yields a prediction: baby birds of species that experience high rates of nest predation should produce softer begging signals of higher frequency than nestlings of other species less often victimized by nest predators.<br>&emsp;一个关于乞食行为的假说认为，乞食声已经进化出一种避免引起捕食者注意并及时作出预警的特性：比起那些较少受到捕食者捕食的雏鸟相比，被捕食率高的鸟类的雏鸟需要发出更轻柔频率更好的叫声。</p></blockquote><h1 id="TPO-20-Listening"><a href="#TPO-20-Listening" class="headerlink" title="TPO 20 Listening"></a>TPO 20 Listening</h1><h2 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h2><p>&emsp;错题2[目的题]:仔细听这个student要干什么，梳理脉络</p><h2 id="L1"><a href="#L1" class="headerlink" title="L1"></a>L1</h2><p>词汇: <em>maxims</em></p><p>题目逻辑关系很清晰，逐点记录即可</p><h2 id="L2"><a href="#L2" class="headerlink" title="L2"></a>L2</h2><p>&emsp;错题13[内容主旨]:找到关键词</p><p>&emsp;错题14[内容主旨]:分析原因，（听tapes时记录得不够详细准确）</p><h2 id="L3"><a href="#L3" class="headerlink" title="L3"></a>L3</h2><p>&emsp;错题7[特点分析]:folk legends的特点：一定的真实性，错在干扰选项A</p><blockquote><p>They are very imaginative<br>They are somewhat realistic</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图学习</title>
      <link href="/2019/03/30/UML%E7%B1%BB%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/30/UML%E7%B1%BB%E5%9B%BE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>阅读材料来自于：<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">深入浅出UML类图</a><br><br>&emsp;类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>&emsp;类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在软件系统运行时，类将被实例化成对象(Object)，对象对应于某个具体的事物，是类的实例(Instance)。<br><br>&emsp;类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。</p><hr><h1 id="类的UML图示"><a href="#类的UML图示" class="headerlink" title="类的UML图示"></a>类的UML图示</h1><p>&emsp;在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，如定义一个Employee类，它包含属性name、age和email，以及操作modifyInfo()，在UML类图中该类如图1所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112311.jpg" alt><br>&emsp;<br>在UML类图中，类一般由三部分组成：</p><ol><li>第一部分是类名：每个类都必须有一个名字，类名是一个字符串。</li><li>第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性</li></ol><p>UML规定属性的表示方式为：<strong>可见性 名称:类型 [ = 缺省值 ]</strong></p><p>其中：</p><ul><li>“可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号<strong>+、-</strong>和<strong>#</strong>表示。</li><li>“名称”表示属性名，用一个字符串表示。</li><li>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。</li><li>“缺省值”是一个可选项，即属性的初始值。</li></ul><ol start="3"><li>第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。</li></ol><p>UML规定操作的表示方式为：<strong>可见性 名称(参数列表) [ : 返回类型]</strong><br>其中：</p><ul><li>“可见性”的定义与属性的可见性定义相同。</li><li>“名称”即方法名，用一个字符串表示。</li><li>“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。</li><li>“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。</li></ul><p>在类中，操作method1的可见性为public(+)，带入了一个Object类型的参数par，返回值为空(void)；操作method2的可见性为protected(#)，无参数，返回值为String类型；操作method3的可见性为private(-)，包含两个参数，其中一个参数为int类型，另一个为int[]类型，返回值为int类型。<br><img src="http://www.uml.org.cn/oobject/images/2012112312.jpg" alt></p><hr><h1 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h1><p>&emsp;在软件系统中，类并不是孤立存在的，类与类之间存在各种关系，对于不同类型的关系，UML提供了不同的表示方式。</p><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>&emsp;关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系.<br><img src="http://www.uml.org.cn/oobject/images/2012112314.jpg" alt></p><h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p>&emsp;默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品。<br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt></p><h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p>&emsp;类的关联关系也可以是单向的，单向关联用带箭头的实线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt></p><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>&emsp;在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象，如图所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt></p><h3 id="多重关联"><a href="#多重关联" class="headerlink" title="多重关联"></a>多重关联</h3><p>&emsp;了解即可</p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>&emsp;聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt><br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="comment">//构造注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.engine = engine;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设值注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEngine</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>&emsp;组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。</p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt></p><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>&emsp;泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123112.jpg" alt></p><h2 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h2><p>&emsp;在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口：<br><img src="http://www.uml.org.cn/oobject/images/20121123113.jpg" alt></p><p>&emsp;接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示：<br><img src="http://www.uml.org.cn/oobject/images/20121123114.jpg" alt></p><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致那些人们</title>
      <link href="/2019/03/27/%E8%87%B4%E9%82%A3%E4%BA%9B%E4%BA%BA%E4%BB%AC/"/>
      <url>/2019/03/27/%E8%87%B4%E9%82%A3%E4%BA%9B%E4%BA%BA%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>Those who are dead</em><br><em>Are not dead</em><br><em>They’re just living in my head.</em><br><em>And since i fell</em><br><em>For that spell</em><br><em>I am living there as well</em><br>                             ——<em>Coldplay 《42》</em></p></blockquote><p>&emsp;致那些失去亲爱的人的人们。<br><br></p><p><br>&emsp;其实想想人们都将往那里走去，“死亡是一座灯塔”。人常说死者离开人世走入记忆，但生者如何依托死者的记忆活着呢？<br><br>&emsp;遇到这种事，想必你没法痛痛快快地宣泄吧？温暖的东西恐怕我不大能写出来了，那种东西在我眼里几乎为骗局。你感受的多，你越觉得累，你觉得精疲力尽走投无路却根本没有柳暗花明。接受吧。<br><br>&emsp;因为那就是生活的真相。<br><br>&emsp;与其说以前生活多美好，只管吃饭只管玩闹，倒不如想想所谓的岁月静好其实是一代又一代人的“负重前行”,只不过大多数人只有“后人乘凉”的享受欲，将那“前人栽树”的前提与责任抛之脑后，最后一人赤手空拳来到新天地时埋怨着世界的不近人情，不有些可笑吗？<br><br>&emsp;我承认我有依赖他人的习惯，我承认自己的懦弱与胆怯。<br><br>&emsp;很多时候我也意识到，只有我边说着话，边兀自重温悲伤的故事。<br><br>&emsp;人们的悲欢大抵不相通，鲁迅早就说过了。不过还是有相通的时候吧，真正的痛苦来自于真正的爱，尽管如此，我还是要去爱，爱那些值得我痛苦的人，爱到不得不重视他们的痛苦，爱到他们的难过也变成我的难过。“重要的不是治愈，而是病痛着活下去。”（加缪）<br><br>&emsp;那人离开了，仿佛处处无此人，又处处皆此人。此人离去，似星火散落四周。<br><br>&emsp;是啊，相处的时间太短，余生太长；是啊，人生太短，遗憾又太长。时隔多日，当我因脑海中那些个人的点点滴滴因时光斑驳至模糊伤怀时，才明白生命中短暂的相遇意义何在。我自认为了解生命，参悟到了生命的真谛——生命就是失去。<br><br>&emsp;三毛也失去了何西，杨绛最后不过一人踽踽独行。<br><br>&emsp;由此说来，你，我，还有他，不过都是天涯倦客，心中惦记那归路，希望回到那些细细碎碎温馨的尘事中。</p><blockquote><p>&emsp;我们不必留恋所谓过去的好时光，那个时候生活充满艰难危险和迷惘；我们也不必为今天的时代过分沮丧，因为今天，也总有一天会被人们称作是——过去的好时光。<br>&emsp;过去的人真笨，过去的人真难。<br>   ——刘慈欣《地火》</p></blockquote><p>&emsp;且将昨日的欢喜悲伤抛去，离开那影影绰绰的回忆，让尘归尘，土归土吧。一切，不都是世界的物质循环吗？</p><p><br><em>趁天空还明媚，蔚蓝</em><br><br><em>趁花朵鲜艳</em><br><br><em>趁眼睛来看一切美好</em><br><br><em>趁夜幕还没降临</em><br><br><em>呵 趁现在时流还平静</em><br><br><em>做你的梦吧 且憩息</em><br><br><em>等醒来再哭泣</em></p>]]></content>
      
      
      <categories>
          
          <category> 竹林深处 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竹林深处 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记Mutable</title>
      <link href="/2019/03/23/SC_Mutable/"/>
      <url>/2019/03/23/SC_Mutable/</url>
      
        <content type="html"><![CDATA[<p><strong>Classifying Types and Operations</strong><br><a id="more"></a></p><h1 id="Mutable-and-immutable-types"><a href="#Mutable-and-immutable-types" class="headerlink" title="Mutable and immutable types"></a>Mutable and immutable types</h1><p>&emsp;<strong>Types, whether built-in or user-defined, can be classified as mutable or immutable</strong><br><br>可变类型的对象：提供了可改变其内部数据的值的操作</p><blockquote><p>The objects of a mutable type can be changed: that is, they provide operations which when executed cause the results of other operations on the same object to give different results.</p></blockquote><p>举例：</p><ol><li>Date是mutable，能够调用setMonth()函数的并且观察到getMonth()操作的变化。</li><li>String是immutable的，其<strong>操作不改变内部值，而是构造新的对象</strong></li><li>StringBuilder为可变的。</li></ol><h1 id="Classifying-the-operations-of-an-abstract-type"><a href="#Classifying-the-operations-of-an-abstract-type" class="headerlink" title="Classifying the operations of an abstract type"></a>Classifying the operations of an abstract type</h1><p> <strong>Creators</strong> create new objects of the type.</p><blockquote><p>A creator may take an object as an argument, but not an object of the type being constructed</p></blockquote><hr><p> <strong>Producers</strong> create new objects</p><blockquote><p>The concat() method of String , for example, is a producer: it takes two strings and produces a new one representing their concatenation. </p></blockquote><hr><p><strong>Observers</strong> take objects of the abstract type and return objects of a different type.</p><blockquote><p>The size() method of List , for example, returns an int </p></blockquote><hr><p><strong>Mutators</strong> change objects.</p><blockquote><p>The add() method of List , for example, mutates a list by adding an element to the end.</p></blockquote><p>“真是大国重器”呐！ </p><ul><li><p>构造器例子</p><p>在SC的lab2中构造Vertex。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO constructor</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> (String)label - represents the vertex</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> (Map) toVertex - represent the arc between vertex and weight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String source,String target, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">label = source;</span><br><span class="line">    toVertex = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">toVertex.put(target, weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.label = name;</span><br><span class="line"><span class="keyword">this</span>.toVertex = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器里面要用<code>this</code>而不能<code>Vertex.label = name;</code> </p>]]></content>
      
      
      <categories>
          
          <category> 软件构造笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构造笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA学习记录</title>
      <link href="/2019/03/22/JAVA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/03/22/JAVA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Lab2的要求看得我一头雾水，又是接口又是不变量的，往日中学时代被老师手把手教的日子果真一去不复返了,不过这种大学的学习方式可能更接近于以后人生中的独自上下求索的艰辛历程吧……<a id="more"></a></p><h1 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h1><p>&emsp;根据百度百科</p><blockquote><p>&emsp;Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。<br><br>&emsp;两种含义：一，Java接口，Java语言中存在的结构，有特定的语法和结构；二，一个类所具有的方法的特征集合，是一种逻辑上的抽象。前者叫做“Java接口”，后者叫做“接口”。</p></blockquote><h1 id="静态方法和非静态方法"><a href="#静态方法和非静态方法" class="headerlink" title="静态方法和非静态方法"></a>静态方法和非静态方法</h1><p>&emsp;<br>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p><h1 id="constructor（创造器）"><a href="#constructor（创造器）" class="headerlink" title="constructor（创造器）"></a>constructor（创造器）</h1><p>&emsp;构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。例如软件构造实验中需要写一个ConcreteEdgesGraph<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   // TODO constructor</span><br><span class="line">/**</span><br><span class="line"> * construct a empty graph</span><br><span class="line"> */</span><br><span class="line">public ConcreteEdgesGraph() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Assert-断言）"><a href="#Assert-断言）" class="headerlink" title="Assert (断言）"></a>Assert (断言）</h1><p>&emsp;(1)<code>assert [boolean表达式]</code><br><br>&emsp;&emsp;如果表达式为true,程序继续执行，若为false则抛出AssertionError，并终止执行。<br><br>&emsp;(2)<code>assert [boolean 表达式:错误表达式(日志)]</code><br><br>&emsp;&emsp;如果表达式为true，程序继续执行。如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。</p><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><p>&emsp;就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。详见<a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener">迭代器</a><br><br>而对应于SC实验中，对边的遍历涉及到迭代器的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Edge&gt; iteratorEdges = new ArrayList&lt;Edge&gt;(edges);</span><br><span class="line">    for(Edge i : iteratorEdges) &#123;</span><br><span class="line">    if(i.getSource().equals(vertex) || i.getTarget().equals(vertex))</span><br><span class="line">    edges.remove(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>简而言之就是可以存在这个东西，如果没有此声明的话会出错-没有实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final String label;</span><br><span class="line">private final Map&lt;String, Integer&gt; toVertex;  //声明存在合法变量</span><br></pre></td></tr></table></figure></p><p>对应于以下的实例化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toVertex = new HashMap&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>&emsp;Java泛型（generics）是JDK5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br><br>&emsp;在软件工程课程里面<a href="http://web.mit.edu/6.031/www/sp17/psets/ps2/" target="_blank" rel="noopener">Poetic Walks</a>P3应用到了泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Vertex&lt;L&gt; &#123;</span><br><span class="line"> private final L label;</span><br><span class="line">    private final Map&lt;L, Integer&gt; toVertex;  //声明存在合法变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SC_Lab2和Chapter3</title>
      <link href="/2019/03/19/SC%E5%AE%9E%E9%AA%8C%E4%BA%8C&amp;%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2019/03/19/SC%E5%AE%9E%E9%AA%8C%E4%BA%8C&amp;%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>  阅读材料来自于MIT的Software Construction课程 <a href="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/" target="_blank" rel="noopener">Reading 11: Abstraction Functions &amp; Rep Invariants</a>.<br><br>要点如下:<a id="more"></a><br><br>·<strong>invariant</strong><br><br>·<strong>representation exposure</strong><br><br>·<strong>abstraction functions</strong><br><br>·<strong>representation invariants</strong><br><br>The rep invariant will make it easier to catch bugs caused by a corrupted data structure.</p><h1 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h1><p>&emsp;一个好的抽象数据型(ADT)的关键：能否<strong>preserves its own invariants</strong></p><h2 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h2><p>&emsp;看下面的例子<br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String author;</span><br><span class="line"><span class="keyword">public</span> String text;</span><br><span class="line"><span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;  如何确保<code>Tweet</code>类是不可变的呢？即一旦建立，相关属性不改变。<br><br>&emsp;威胁之一是客户端能够直接修改这个域。Representation exposure ：code outside the class can modify the representation directly.<br><br>&emsp;<br>不过辛亏有<code>private</code>和<code>final</code>，官方给出如下解释</p><blockquote><p>The private and public keywords indicate which fields and methods are accessible only within the class and which can be accessed from outside the class. The final keyword also helps by guaranteeing that the fields of this immutable type won’t be reassigned after the object is constructed.</p></blockquote><p><br>&emsp;一种策略就是<strong>防御式拷贝(defensive copying)</strong>。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;值得注意的是，另一种copy a mutable object is clone(),但是有些问题，暂且不谈。<br><br><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">       date.setHours(i);</span><br><span class="line">       list.add(<span class="keyword">new</span> Tweet(<span class="string">"rbmllr"</span>, <span class="string">"keep it up! you can do it"</span>, date));</span><br><span class="line">   &#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/tweetEveryHourToday.png" alt><br><br>&emsp;所以不变性又被破坏了，采用一下策略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Immutable-wrappers-around-mutable-data-types"><a href="#Immutable-wrappers-around-mutable-data-types" class="headerlink" title="Immutable wrappers around mutable data types"></a>Immutable wrappers around mutable data types</h2><p>&emsp;此时，轮到我们的<code>Collections.unmodifiableList()</code>亮相。但是一个downside就是得到的所谓的immutability只是在runtime，but not at compile time. Java也不会在你试着<code>sort()</code>这个unmodifiable list的时候警告你，反而抛给你一个冷冰冰的异常。<br><br>&emsp;注意阅读练习里面的array相关的problem</p><h1 id="Rep-invariant-and-abstraction-function"><a href="#Rep-invariant-and-abstraction-function" class="headerlink" title="Rep invariant and abstraction function"></a>Rep invariant and abstraction function</h1><p>&emsp;关键不仅仅在于选取两个集合Space，而且在于选取什么的元素为合法，并且怎样将它们对应成抽象的值。</p><blockquote><p>not only choosing the two spaces… but also deciding which rep values are legal, and how to interpret them as abstract values.</p></blockquote><p>比如根据此图，我们得到下面的映射：<img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/charset-af-ri.svg" alt><br>以下要点：<br><br>&emsp;<strong>·每一个抽象类都对应有原象</strong><br><br>&emsp;<strong>·一些抽象类映射前的原象不止一个</strong><br><br>&emsp;<strong>·而在集合R中并非所有元素都有映射的象</strong><br><br>&emsp;和实验相关一点，AF就是某个成员变量代表的抽象概念，RI就是对这个成员变量的限制。然而我这个傻子恍然大悟，AF就是”Abstraction functioin”,RI即为” Representation invariant”啊！！！</p><blockquote><p><strong>抽象函数AF</strong>：R和A之间映射关系的函数，即如何去解 释R中的每一个值为A中的每一个值。<br><br><strong>表示不变性RI</strong>：某个具体的“表示”是否是“合法的”<br><br>&emsp;可将RI看作：所有表示值的一个子集，包含了所有合法的表示值<br><br> &emsp;也可将RI看作：一个条件，描述了什么是“合法”的表示</p></blockquote><p><br>&emsp;从rep values到其所表示的抽象值之间的映射表示如下</p><blockquote><p>AF: R -&gt; A</p></blockquote><p> 同时也可以用<code>R → Boolean</code>的映射表示是否rep value和一个abstract values之间存在着对应关系。如下图所示<br><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/charset-norepeats.svg" alt><br>&emsp;对于表达值（rep value）而言， RI(r) 为真当且仅当r被AF映射。RI(“a”) = true, RI(“ac”) = true, 并且 RI(“acb”) = true, 但 RI(“aa”) = false and RI(“abbc”) = false.<br><br>&emsp;尽管有着不相同类型的rep value space 和相同的rep invariant，我们可以构建出不同的映射。例如“acgg”表示字符串之间的范围，[a-c]和[g-g]，所以代表的元素是集合set{a,b,c,g}.<br><br>&emsp;对于client of an abstract data type而言，visible and documented的应该为：abstract value space, creators, observes. 而不可见：abstraction function, rep 和 rep invariant.</p><blockquote><p>Rep invariant is a function from rep values to boolean.</p></blockquote><h2 id="Checkint-the-rep-invariant"><a href="#Checkint-the-rep-invariant" class="headerlink" title="Checkint the rep invariant"></a>Checkint the rep invariant</h2><p>check的特点：</p><blockquote><p>&emsp;It’s good for an implementer to call <code>checkRep()</code> just before returning from a public method of an ADT class.<br><br>&emsp;<code>checkRep()</code> asserts the rep invariant.</p></blockquote><h2 id="No-null-values-in-the-rep"><a href="#No-null-values-in-the-rep" class="headerlink" title="No null values in the rep"></a>No null values in the rep</h2><h2 id="Beneficnet-mutation"><a href="#Beneficnet-mutation" class="headerlink" title="Beneficnet mutation"></a>Beneficnet mutation</h2><h1 id="Documenting-the-AF-RI-and-safety-from-rep-exposure"><a href="#Documenting-the-AF-RI-and-safety-from-rep-exposure" class="headerlink" title="Documenting the AF,RI, and safety from rep exposure"></a>Documenting the AF,RI, and safety from rep exposure</h1><p>注意，在描述rep invariant and abstraction function的时候，必须注意：<br><br>&emsp;不能仅仅用“域内全员合法”来简简单单概括RI，重要的是explain是如何区分“合法”和“非法”的。<br><br>&emsp;同样的，对于AF而言，仅仅声明“represents a set of charaters”也是不够的。而应该<strong>define precisely how the concrete field values are interpreted</strong><br>而根据<a href="http://https://blog.csdn.net/weixin_39643135/article/details/80231152" target="_blank" rel="noopener">同学的解释</a></p><blockquote><p><strong>Rep exposure</strong>：<br><br>&emsp;java中数据类型分为mutable和immutable的，对前者进行的操作可能会改变其内部数据；而对后者的操作不改变其内部值，而是构造新的对象。因此，对于mutable的数据，如果没有良好的保护，意味着client对其的调用可以直接修改内部数据。</p></blockquote><h3 id="What-an-ADT-specification-may-talk-about"><a href="#What-an-ADT-specification-may-talk-about" class="headerlink" title="What an ADT specification may talk about"></a>What an ADT specification may talk about</h3><p><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/adt-firewall.svg" alt><br><br></p><h1 id="ADT-invariants-replace-preconditions"><a href="#ADT-invariants-replace-preconditions" class="headerlink" title="ADT invariants replace preconditions"></a>ADT invariants replace preconditions</h1><p>An invariant is a property of a program that is always true, for every possible runtime state of the program.<br><br>&emsp;为什么需要不变量？ <del>因为爱情。</del>保持程序的“正确性”，容易发现错误。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="SPEC"><a href="#SPEC" class="headerlink" title="SPEC"></a>SPEC</h2><p>&emsp;SPEC is the abbreviation of the word-specification，规约。client能干什么，不能干什么，输入输出满足的条件将在spec中罗列得清清楚楚。<br>大致要点</p><ol><li>Function / method in programming language</li><li>Specification: Programming for communication </li><li>Designing specifications<br><br><h3 id="Spec-Structure"><a href="#Spec-Structure" class="headerlink" title="Spec Structure"></a>Spec Structure</h3></li></ol><ul><li>前置条件 precondition(对客户端的约束，在使用方法时必须满足的条件）<blockquote><p>The precondition is an obligation on the client (i.e., the caller of the method). It’s a condition over the state in which the method is invoked. </p></blockquote></li></ul><ul><li><p>后置条件 postcondition(后置条件：对开发者的约束，方法结束时必须满足的条件)</p><blockquote><p>The postcondition is an obligation on the implementer of the method.  </p></blockquote></li><li><p>– Precondition , indicated by the keyword <strong>requires</strong><br><br>– Postcondition , indicated by the keyword <strong>effects</strong><br><br>相应于<code>@return</code>和<code>@param</code>呢？来看课件讲义：<br><br>&emsp;Parameters are described by <strong>@param</strong> clauses and results are described by @return and <strong>@throws</strong> clauses.<br><br>&emsp;Put the preconditions into <strong>@param</strong> where possible, and postconditions into <strong>@return</strong> and <strong>@throws</strong>.<br><br></p><h3 id="规约强弱？"><a href="#规约强弱？" class="headerlink" title="规约强弱？"></a>规约强弱？</h3><p><br>&emsp;规约的强度S2&gt;=S1 A specification S2 is stronger than or equal to a specification S1 if </p></li><li>S2’s precondition is weaker than or equal to S1’s  前置条件更弱 </li><li>S2’s postcondition is stronger than or equal to S1’s, for the states that satisfy S1’s precondition. 后置条件更强<br><br>&emsp;简而言之，spec变强就是<strong>更放松的前置条件</strong> + <strong>更严格的后置条件</strong> </li></ul><h1 id="漫漫实验路"><a href="#漫漫实验路" class="headerlink" title="漫漫实验路"></a>漫漫实验路</h1><h2 id="ea"><a href="#ea" class="headerlink" title="-ea"></a>-ea</h2><p>&emsp;多谢橙子的提醒，在poet测试里面需要用到assert断言，而必须要在Eclipse中开启assert选项。<a href="https://blog.csdn.net/styshoo/article/details/48209493" target="_blank" rel="noopener">详情</a></p><blockquote><p>Windows -&gt; Preferences -&gt;Java -&gt;Installed JREs -&gt;待使用的JDK -&gt;Edit -&gt;Default VM Arguments文本框中输入:-ea</p></blockquote><h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>&emsp;本人在实验里面经常用到对抛出异常的检测，下面以lab2中Board异常检测为例。Board规定了，应该为”chess”或者”go”类型，而在这里传入”tt”显然会抛出异常的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Board</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(type == <span class="string">"chess"</span>)</span><br><span class="line">N = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">"go"</span>)</span><br><span class="line">N = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not a game that we'll provide for you"</span>);</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Test for exception</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Test</span>(expected = RuntimeException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">typeExceptionTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Board board = <span class="keyword">new</span> Board(<span class="string">"tt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h1><h2 id="区分override-和-overload"><a href="#区分override-和-overload" class="headerlink" title="区分override 和 overload"></a>区分override 和 overload</h2><p>&emsp;overload用同一个方法名字但是输入不同的参数列表，比如本人在实验中构造的函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(L source,L target, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">label = source;</span><br><span class="line">    toVertex = <span class="keyword">new</span> HashMap&lt;L, Integer&gt;();</span><br><span class="line">toVertex.put(target, weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(L name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.label = name;</span><br><span class="line"><span class="keyword">this</span>.toVertex = <span class="keyword">new</span> HashMap&lt;L, Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Evan的这篇文章很好：<a href="http://evanclark.top/2019/03/26/hashCode/" target="_blank" rel="noopener">Java 何时需要重写hashCode()和equals()</a><br>&emsp;此外override在run time检查，而overload是在compile阶段就进行检查</p><h1 id="3-5-Equality-in-ADT-and-OOP"><a href="#3-5-Equality-in-ADT-and-OOP" class="headerlink" title="3.5 Equality in ADT and OOP"></a>3.5 Equality in ADT and OOP</h1><h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><p>&emsp;等价关系(Equivalence Relation)：自反、对称、传递</p><h2 id="Equality-in-immutable-types"><a href="#Equality-in-immutable-types" class="headerlink" title="Equality in immutable types"></a>Equality in immutable types</h2><ol><li><strong>a equals b if and only if f(a) = f(b)</strong>，即AF映射同样的结果。</li><li>站在外部角度，对两个对象调用任何相同操作，都能得到相同结果，认为等价性成立。<br>举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Duration &#123;</span><br><span class="line">    private final int mins;</span><br><span class="line">    private final int secs;</span><br><span class="line">    // Rep invariant:</span><br><span class="line">    //    mins &gt;= 0, secs &gt;= 0</span><br><span class="line">    // Abstraction function:</span><br><span class="line">    //    AF(min, secs) = the span of time of mins minutes and secs seconds</span><br><span class="line"></span><br><span class="line">    /** Make a duration lasting for m minutes and s seconds. */</span><br><span class="line">    public Duration(int m, int s) &#123;</span><br><span class="line">        mins = m; secs = s;</span><br><span class="line">    &#125;</span><br><span class="line">    /** @return length of this duration in seconds */</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return mins*60 + secs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中下列那些等价呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = new Duration (1, 2);</span><br><span class="line">Duration d2 = new Duration (1, 3);</span><br><span class="line">Duration d3 = new Duration (0, 62);</span><br><span class="line">Duration d4 = new Duration (1, 2);</span><br></pre></td></tr></table></figure></p><h2 id="区分equals和“-”"><a href="#区分equals和“-”" class="headerlink" title="区分equals和“==”"></a>区分equals和“==”</h2><p>&emsp;等价性：引用等价性和对象等价性</p><p>&emsp;对基本数据类型，使用<strong>==</strong>判定相等</p><p>&emsp;对对象类型，使用equals.</p><ul><li>== 和内存空间相关。</li></ul><p>再看这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span> </span>&#123;</span><br><span class="line">    ...   </span><br><span class="line">    <span class="comment">// Problematic definition of equals()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Duration that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = <span class="keyword">new</span> Duration (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Duration d2 = <span class="keyword">new</span> Duration (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Object o2 = d2;</span><br><span class="line">d1.equals(d2) → <span class="keyword">true</span></span><br><span class="line">d1.equals(o2) → <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>&emsp;答案为true和false。d2的类型是Duration，而o2的类型是Object，在类Duration里面的equals无法对这个o2进行等价判断。而且o2和d1指向并非同一内存空间，因此会返回<strong>false</strong>。</p><p>&emsp;上述给的例子是overload而非override。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Duration extends Object &#123;</span><br><span class="line">    // explicit method that we declared:</span><br><span class="line">    public boolean equals(Duration that) &#123;</span><br><span class="line">        return this.getLength() == that.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    // implicit method inherited from Object:</span><br><span class="line">    public boolean equals(Object that) &#123;</span><br><span class="line">        return this == that;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;equals三件套：（1）是否为空 （2）类型是否相同 （3）根据AF设计相等判断。但是有一弊处：在没有AF情况下判断每个域的等价性，这是不合理的。</p><h3 id="Hashcode"><a href="#Hashcode" class="headerlink" title="Hashcode"></a>Hashcode</h3><p>&emsp;hashCode -&gt; memory address!!!</p><p>&emsp;规定一个原则：等价的对象必须有相同的hashCode。（不相等的对象也可以映射为同样的hashCode但性能会变差）</p><blockquote><p>A general rule:<br>Always override hashCode() when you override equals()</p></blockquote><h2 id="Equals-of-Mutable-Types"><a href="#Equals-of-Mutable-Types" class="headerlink" title="Equals of Mutable Types"></a>Equals of Mutable Types</h2><p>&emsp;mutable：</p><ul><li>观察等价性（在不改变状态情况下，两个对象是否一致）</li><li>行为等价性 (调用对象的任何方法都展示出一致的结果)</li></ul><p>&emsp;对可变类型来说，往往倾向于实现严格的观察等价性(observational equality)。但在某些时候观察等价性可能导致bug甚至可能破坏RI。</p><p><strong>immutable类型重写equals和hashCode()，但是mutable类型就不必重写</strong></p>]]></content>
      
      
      <categories>
          
          <category> 软件构造笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件构造笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鄙人胡诌</title>
      <link href="/2019/03/19/%E9%84%99%E4%BA%BA%E6%9D%82%E8%B0%88/"/>
      <url>/2019/03/19/%E9%84%99%E4%BA%BA%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  自修自持莫道此间非彼岸，即心即佛须知东土是西天</p></blockquote><hr><p> &ensp; 羡艳着橙子和钟哥的博客，自己也心痒痒，谁所菜鸡不能有自己的鸡笼？于是乎我也按着教程一步一步地de着bug，学着毫无技术含量的操作。<br><br><br>&ensp;或许写博客当有中学时代拿着尺子和铅笔一点点打格整理笔记的美感？我挺喜欢手字笔录的方式，但怎奈这越学越深的计算机世界不给你手字笔录的时间让你横平竖直工笔正楷地整理笔记。<br><br><br>&ensp;《离骚》中有“朝濯发于汤谷兮，夕晞余身兮九阳”，闭目仿佛看见一身高八尺有余形貌昳丽的长发美男于光中背对着你，可瞅瞅我现在满脸油光，痘印未消，面如土色，发型凌乱，眼小无神，体形消瘦······（再说下去我都把我自己说抑郁了）。美男这辈子估计是够呛，或许找个颜值高点的妹子改良基因后能让我儿子当上美男就不错了，我再努努力当上富二代他爹？<br><br><br>&ensp; 一点一点走吧，搭这个博客的时候曾经一度想放弃，为什么那么多的错？那么多的异常？<br><br><br>&ensp; 但是爹一直反对我做事三分钟热度或者半途而废。秉着“吾乃光宗耀祖之孙氏”的信念，忍着不挤额头上痘痘的冲动，我耐着性子开始了以后的博客之路。不过也好，有个能够宣泄的方寸之地······<br><br><br>&ensp; “是非曲吉祥物”是我和发小一块玩梦幻西游取的第一个人物名字，剑侠客-大唐官府。十多年来，人们走的走，留的留，自己也从任性妄为到忍耐包容的路上自修自持。有些事能够想，有些事只能放，放下那无奈不甘的执念吧。<br><br><br>&ensp; 完善阿里云的信息时跳出密保问题，“你儿时最好的伙伴”，我不假思索地填上cq，可是我们好久好久都没见面了，甚至好久好久都没有说过话了，我们仅存的联系方式就剩下了QQ，我搬了家，他去了外地。但是想一想，人生哪有这么多时间给你感慨呢？孤独的不仅仅是孤单的一人，还有那秋风乍起时望着万家灯火而独自彳亍的异乡客。<br><br><br>&ensp;不过当个风筝也是好的，虽被一线束缚起来，总不至于落得无处可归，总有人惦记着你，牵扯着你，不肯松手。<br><br><br>&ensp;可能是经历了一些事吧，我最近竟能在看似千篇一律的生活中活出一瞬间的“幸福感”：雏菊的花又开了些，托福听力又能多听懂些叽里呱啦的词了，洗澡的水温舒服了些······也忘了在哪抄的的这些：<br><br></p><blockquote><p>你为什么会爱上人类？他们没有永生，脆弱而匆忙<br><br>  &ensp;&ensp;就因为他们没有永生，害怕死亡，才有那么脆弱和匆忙。我爱上的是那脆弱中的争取和躁动，我爱上的是那随时会失去的短暂和恐慌。</p></blockquote><p>&ensp;穷且意坚，不堕青云之志。当自强，于人生路上不忘克己复礼。</p>]]></content>
      
      
      <categories>
          
          <category> 竹林深处 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竹林深处 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
