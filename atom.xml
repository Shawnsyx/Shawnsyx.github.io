<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>是非曲吉祥物</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="shawnsyx.top/"/>
  <updated>2019-03-30T15:03:17.785Z</updated>
  <id>shawnsyx.top/</id>
  
  <author>
    <name>霄先生吃元宵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>English_3.30</title>
    <link href="shawnsyx.top/2019/03/30/English-3-30/"/>
    <id>shawnsyx.top/2019/03/30/English-3-30/</id>
    <published>2019-03-30T14:05:58.000Z</published>
    <updated>2019-03-30T15:03:17.785Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;第一篇英语笔记，道阻且长。</p><p>&emsp;错的最多的就是每篇的压轴题：6选3，几乎没有全对过，哎呀我的心呀。</p><h1 id="TPO-11-Reading"><a href="#TPO-11-Reading" class="headerlink" title="TPO 11 Reading"></a>TPO 11 Reading</h1><hr><h2 id="Ancient-Egyptian-Sculpture"><a href="#Ancient-Egyptian-Sculpture" class="headerlink" title="Ancient Egyptian Sculpture"></a>Ancient Egyptian Sculpture</h2><p>&emsp;大体讲了埃及建筑物的特点，新词<strong>frontality</strong>，无论材质如何（stone，wooden or metal），都体现这个“正面性”，展示雕塑的姿态。在此基础上探讨了雕塑decorative作用等等……</p><p>&emsp;错题2，事实信息题,根据提问，应该从段落的文句中寻找答案，冒号之后罗列雕塑不受欢迎的原因。</p><blockquote><p>Why did the Egyptians not develop sculpture in which the body turned and twisted through space like classical Greek statuary? </p></blockquote><p>&emsp;错题14：两个错的选项要根据原文找矛盾，关键地方是功能性评价，重要性等方面，以及性质的对比。</p><p>词汇方面：<em>divine pillared（pillar）deity elite depicts</em></p><hr><h2 id="Orientation-and-Navigation"><a href="#Orientation-and-Navigation" class="headerlink" title="Orientation and Navigation"></a>Orientation and Navigation</h2><p>&emsp;讲了鸟类定位，主要行文方式：罗列一系列的实验并穿插猜测和结论。第一段提出问题以及引出主要的实验研究人员Gustave Kramer</p><p>&emsp;错题25：组织结构题，可知本文应该利用一系列实验去证明“鸟儿在日间和夜间的定位方法”<br><del>A structured argument about the importance of internal versus external cues for navigation is presented</del><br>而是：A number of experiments are described to support the idea that birds use the Sun and the night sky to navigate.</p><p>&emsp;错题28[概要小结]:错因：信息矛盾-没有关注原文“一系列”实验与题中阐述的”in one set”矛盾。</p><p>词汇方面：<em>flutter overcast surmise preposterous(荒谬的) versus(prep.与之相对)</em></p><hr><h2 id="Begging-by-Nestlings"><a href="#Begging-by-Nestlings" class="headerlink" title="Begging by Nestlings"></a>Begging by Nestlings</h2><p>一言蔽之：鸟儿叫 = 爸妈给食 + predators</p><p>&emsp;错题37[事实信息题]:根据关键词定位相关段落（第四段)+排除法</p><p>&emsp;错题42[概要小结题]:随缘吧</p><p>词汇方面：<em>conceal</em></p><p>难句理解</p><blockquote><p>The hypothesis that begging calls have evolved properties that reduce their potential for attracting predators yields a prediction: baby birds of species that experience high rates of nest predation should produce softer begging signals of higher frequency than nestlings of other species less often victimized by nest predators.<br>&emsp;一个关于乞食行为的假说认为，乞食声已经进化出一种避免引起捕食者注意并及时作出预警的特性：比起那些较少受到捕食者捕食的雏鸟相比，被捕食率高的鸟类的雏鸟需要发出更轻柔频率更好的叫声。</p></blockquote><h1 id="TPO-20-Listening"><a href="#TPO-20-Listening" class="headerlink" title="TPO 20 Listening"></a>TPO 20 Listening</h1><h2 id="C1"><a href="#C1" class="headerlink" title="C1"></a>C1</h2><p>&emsp;错题2[目的题]:仔细听这个student要干什么，梳理脉络</p><h2 id="L1"><a href="#L1" class="headerlink" title="L1"></a>L1</h2><p>词汇: <em>maxims</em></p><p>题目逻辑关系很清晰，逐点记录即可</p><h2 id="L2"><a href="#L2" class="headerlink" title="L2"></a>L2</h2><p>&emsp;错题13[内容主旨]:找到关键词</p><p>&emsp;错题14[内容主旨]:分析原因，（听tapes时记录得不够详细准确）</p><h2 id="L3"><a href="#L3" class="headerlink" title="L3"></a>L3</h2><p>&emsp;错题7[特点分析]:folk legends的特点：一定的真实性，错在干扰选项A</p><blockquote><p>They are very imaginative<br>They are somewhat realistic</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;第一篇英语笔记，道阻且长。&lt;/p&gt;
&lt;p&gt;&amp;emsp;错的最多的就是每篇的压轴题：6选3，几乎没有全对过，哎呀我的心呀。&lt;/p&gt;
&lt;h1 id=&quot;TPO-11-Reading&quot;&gt;&lt;a href=&quot;#TPO-11-Reading&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="英语" scheme="shawnsyx.top/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="shawnsyx.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>UML类图学习</title>
    <link href="shawnsyx.top/2019/03/30/UML%E7%B1%BB%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>shawnsyx.top/2019/03/30/UML类图学习/</id>
    <published>2019-03-30T12:04:53.000Z</published>
    <updated>2019-03-30T13:26:37.532Z</updated>
    
    <content type="html"><![CDATA[<p>阅读材料来自于：<a href="http://www.uml.org.cn/oobject/201211231.asp" target="_blank" rel="noopener">深入浅出UML类图</a><br><br>&emsp;类图用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。</p><hr><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>&emsp;类(Class)封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在软件系统运行时，类将被实例化成对象(Object)，对象对应于某个具体的事物，是类的实例(Instance)。<br><br>&emsp;类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。</p><hr><h1 id="类的UML图示"><a href="#类的UML图示" class="headerlink" title="类的UML图示"></a>类的UML图示</h1><p>&emsp;在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，如定义一个Employee类，它包含属性name、age和email，以及操作modifyInfo()，在UML类图中该类如图1所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112311.jpg" alt><br>&emsp;<br>在UML类图中，类一般由三部分组成：</p><ol><li>第一部分是类名：每个类都必须有一个名字，类名是一个字符串。</li><li>第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性</li></ol><p>UML规定属性的表示方式为：<strong>可见性 名称:类型 [ = 缺省值 ]</strong></p><p>其中：</p><ul><li>“可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号<strong>+、-</strong>和<strong>#</strong>表示。</li><li>“名称”表示属性名，用一个字符串表示。</li><li>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。</li><li>“缺省值”是一个可选项，即属性的初始值。</li></ul><ol start="3"><li>第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。</li></ol><p>UML规定操作的表示方式为：<strong>可见性 名称(参数列表) [ : 返回类型]</strong><br>其中：</p><ul><li>“可见性”的定义与属性的可见性定义相同。</li><li>“名称”即方法名，用一个字符串表示。</li><li>“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开。</li><li>“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void)，如果是构造方法，则无返回类型。</li></ul><p>在类中，操作method1的可见性为public(+)，带入了一个Object类型的参数par，返回值为空(void)；操作method2的可见性为protected(#)，无参数，返回值为String类型；操作method3的可见性为private(-)，包含两个参数，其中一个参数为int类型，另一个为int[]类型，返回值为int类型。<br><img src="http://www.uml.org.cn/oobject/images/2012112312.jpg" alt></p><hr><h1 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h1><p>&emsp;在软件系统中，类并不是孤立存在的，类与类之间存在各种关系，对于不同类型的关系，UML提供了不同的表示方式。</p><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>&emsp;关联(Association)关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系.<br><img src="http://www.uml.org.cn/oobject/images/2012112314.jpg" alt></p><h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p>&emsp;默认情况下，关联是双向的。例如：顾客(Customer)购买商品(Product)并拥有商品。<br><img src="http://www.uml.org.cn/oobject/images/2012112315.jpg" alt></p><h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p>&emsp;类的关联关系也可以是单向的，单向关联用带箭头的实线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112316.jpg" alt></p><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>&emsp;在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如：一个节点类(Node)的成员又是节点Node类型的对象，如图所示：<br><img src="http://www.uml.org.cn/oobject/images/2012112317.jpg" alt></p><h3 id="多重关联"><a href="#多重关联" class="headerlink" title="多重关联"></a>多重关联</h3><p>&emsp;了解即可</p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>&emsp;聚合(Aggregation)关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://www.uml.org.cn/oobject/images/2012112319.jpg" alt><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">   private Engine engine;</span><br><span class="line">    //构造注入</span><br><span class="line">   public Car(Engine engine) &#123;</span><br><span class="line">this.engine = engine;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    //设值注入</span><br><span class="line">   public void setEngine(Engine engine) &#123;</span><br><span class="line">    this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Engine &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>&emsp;组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。</p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p><img src="http://www.uml.org.cn/oobject/images/20121123111.jpg" alt></p><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>&emsp;泛化(Generalization)关系也就是继承关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://www.uml.org.cn/oobject/images/20121123112.jpg" alt></p><h2 id="接口与实现关系"><a href="#接口与实现关系" class="headerlink" title="接口与实现关系"></a>接口与实现关系</h2><p>&emsp;在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口：<br><img src="http://www.uml.org.cn/oobject/images/20121123113.jpg" alt></p><p>&emsp;接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现(Realization)关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示：<br><img src="http://www.uml.org.cn/oobject/images/20121123114.jpg" alt></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读材料来自于：&lt;a href=&quot;http://www.uml.org.cn/oobject/201211231.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入浅出UML类图&lt;/a&gt;&lt;br&gt;&lt;br&gt;&amp;emsp;类图用于描述系统中所包含的类以及它
      
    
    </summary>
    
      <category term="笔记" scheme="shawnsyx.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="shawnsyx.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>致那些人们</title>
    <link href="shawnsyx.top/2019/03/27/%E8%87%B4%E9%82%A3%E4%BA%9B%E4%BA%BA%E4%BB%AC/"/>
    <id>shawnsyx.top/2019/03/27/致那些人们/</id>
    <published>2019-03-27T15:16:59.000Z</published>
    <updated>2019-03-28T12:26:32.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>Those who are dead</em><br><em>Are not dead</em><br><em>They’re just living in my head.</em><br><em>And since i fell</em><br><em>For that spell</em><br><em>I am living there as well</em><br>                             ——<em>Coldplay 《42》</em></p></blockquote><p>&emsp;致那些失去亲爱的人的人们。<br><br></p><p><br>&emsp;其实想想人们都将往那里走去，“死亡是一座灯塔”。人常说死者离开人世走入记忆，但生者如何依托死者的记忆活着呢？我并非选择躲在角落里一个人默默舔舐伤口，而是带着那份疼痛活下去。记下这意识流，藉此满足我心里的倾诉欲。<br><br>&emsp;遇到这种事，想必你没法痛痛快快地宣泄吧？温暖的东西恐怕我不大能写出来了，那种东西在我眼里几乎为骗局。你感受的多，你越觉得累，你觉得精疲力尽走投无路却根本没有柳暗花明。接受吧。<br><br>&emsp;因为那就是生活的真相。<br><br>&emsp;与其说以前生活多美好，只管吃饭只管玩闹，倒不如想想所谓的岁月静好其实是一代又一代人的“负重前行”,只不过大多数人只有“后人乘凉”的享受欲，将那“前人栽树”的前提与责任抛之脑后，最后一人赤手空拳来到新天地时埋怨着世界的不近人情，不有些可笑吗？<br><br>&emsp;我承认我有依赖他人的习惯，我承认自己的懦弱与胆怯。<br><br>&emsp;很多时候我也意识到，只有我边说着话，边兀自重温悲伤的故事。<br><br>&emsp;人们的悲欢大抵不相通，鲁迅早就说过了。不过还是有相通的时候吧，真正的痛苦来自于真正的爱，尽管如此，我还是要去爱，爱那些值得我痛苦的人，爱到不得不重视他们的痛苦，爱到他们的难过也变成我的难过。“重要的不是治愈，而是病痛着活下去。”（加缪）<br><br>&emsp;那人离开了，仿佛处处无此人，又处处皆此人。此人离去，似星火散落四周。<br><br>&emsp;是啊，相处的时间太短，余生太长；是啊，人生太短，遗憾又太长。时隔多日，当我因脑海中那些个人的点点滴滴因时光斑驳至模糊伤怀时，才明白生命中短暂的相遇意义何在。我自认为了解生命，参悟到了生命的真谛——生命就是失去。<br><br>&emsp;三毛也失去了何西，杨绛最后不过一人踽踽独行。<br><br>&emsp;由此说来，你，我，还有他，不过都是天涯倦客，心中惦记那归路，希望回到那些细细碎碎温馨的尘事中。</p><blockquote><p>&emsp;我们不必留恋所谓过去的好时光，那个时候生活充满艰难危险和迷惘；我们也不必为今天的时代过分沮丧，因为今天，也总有一天会被人们称作是——过去的好时光。<br>&emsp;过去的人真笨，过去的人真难。<br>   ——刘慈欣《地火》</p></blockquote><p>&emsp;且将昨日的欢喜悲伤抛去，离开那影影绰绰的回忆，让尘归尘，土归土吧。一切，不都是世界的物质循环吗？</p><p><br><em>趁天空还明媚，蔚蓝</em><br><br><em>趁花朵鲜艳</em><br><br><em>趁眼睛来看一切美好</em><br><br><em>趁夜幕还没降临</em><br><br><em>呵 趁现在时流还平静</em><br><br><em>做你的梦吧 且憩息</em><br><br><em>等醒来再哭泣</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Those who are dead&lt;/em&gt;&lt;br&gt;&lt;em&gt;Are not dead&lt;/em&gt;&lt;br&gt;&lt;em&gt;They’re just living in my head.&lt;/em&gt;&lt;br&gt;&lt;em&gt;And since i fell&lt;/em
      
    
    </summary>
    
      <category term="竹林深处" scheme="shawnsyx.top/categories/%E7%AB%B9%E6%9E%97%E6%B7%B1%E5%A4%84/"/>
    
    
      <category term="竹林深处" scheme="shawnsyx.top/tags/%E7%AB%B9%E6%9E%97%E6%B7%B1%E5%A4%84/"/>
    
  </entry>
  
  <entry>
    <title>软件构造笔记Mutable</title>
    <link href="shawnsyx.top/2019/03/23/SC_Mutable/"/>
    <id>shawnsyx.top/2019/03/23/SC_Mutable/</id>
    <published>2019-03-23T13:33:06.000Z</published>
    <updated>2019-03-27T03:33:58.434Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Classifying Types and Operations</strong><br><a id="more"></a></p><h1 id="Mutable-and-immutable-types"><a href="#Mutable-and-immutable-types" class="headerlink" title="Mutable and immutable types"></a>Mutable and immutable types</h1><p>&emsp;<strong>Types, whether built-in or user-defined, can be classified as mutable or immutable</strong><br><br>可变类型的对象：提供了可改变其内部数据的值的操作</p><blockquote><p>The objects of a mutable type can be changed: that is, they provide operations which when executed cause the results of other operations on the same object to give different results.</p></blockquote><p>举例：</p><ol><li>Date是mutable，能够调用setMonth()函数的并且观察到getMonth()操作的变化。</li><li>String是immutable的，其<strong>操作不改变内部值，而是构造新的对象</strong></li><li>StringBuilder为可变的。</li></ol><h1 id="Classifying-the-operations-of-an-abstract-type"><a href="#Classifying-the-operations-of-an-abstract-type" class="headerlink" title="Classifying the operations of an abstract type"></a>Classifying the operations of an abstract type</h1><p> <strong>Creators</strong> create new objects of the type.</p><blockquote><p>A creator may take an object as an argument, but not an object of the type being constructed</p></blockquote><hr><p> <strong>Producers</strong> create new objects</p><blockquote><p>The concat() method of String , for example, is a producer: it takes two strings and produces a new one representing their concatenation. </p></blockquote><hr><p><strong>Observers</strong> take objects of the abstract type and return objects of a different type.</p><blockquote><p>The size() method of List , for example, returns an int </p></blockquote><hr><p><strong>Mutators</strong> change objects.</p><blockquote><p>The add() method of List , for example, mutates a list by adding an element to the end.</p></blockquote><p>“真是大国重器”呐！ </p><ul><li><p>构造器例子</p><p>在SC的lab2中构造Vertex。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO constructor</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> (String)label - represents the vertex</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> (Map) toVertex - represent the arc between vertex and weight</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String source,String target, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">label = source;</span><br><span class="line">    toVertex = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">toVertex.put(target, weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.label = name;</span><br><span class="line"><span class="keyword">this</span>.toVertex = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器里面要用<code>this</code>而不能<code>Vertex.label = name;</code> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Classifying Types and Operations&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软件构造笔记" scheme="shawnsyx.top/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件构造笔记" scheme="shawnsyx.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA学习记录</title>
    <link href="shawnsyx.top/2019/03/22/JAVA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>shawnsyx.top/2019/03/22/JAVA学习记录/</id>
    <published>2019-03-22T03:00:27.000Z</published>
    <updated>2019-03-30T12:07:05.594Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;Lab2的要求看得我一头雾水，又是接口又是不变量的，往日中学时代被老师手把手教的日子果真一去不复返了,不过这种大学的学习方式可能更接近于以后人生中的独自上下求索的艰辛历程吧……<a id="more"></a></p><h1 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h1><p>&emsp;根据百度百科</p><blockquote><p>&emsp;Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。<br><br>&emsp;两种含义：一，Java接口，Java语言中存在的结构，有特定的语法和结构；二，一个类所具有的方法的特征集合，是一种逻辑上的抽象。前者叫做“Java接口”，后者叫做“接口”。</p></blockquote><h1 id="静态方法和非静态方法"><a href="#静态方法和非静态方法" class="headerlink" title="静态方法和非静态方法"></a>静态方法和非静态方法</h1><p>&emsp;<br>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p><h1 id="constructor（创造器）"><a href="#constructor（创造器）" class="headerlink" title="constructor（创造器）"></a>constructor（创造器）</h1><p>&emsp;构造器最大的用处就是在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以通过自定义构造器来实现。例如软件构造实验中需要写一个ConcreteEdgesGraph<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   // TODO constructor</span><br><span class="line">/**</span><br><span class="line"> * construct a empty graph</span><br><span class="line"> */</span><br><span class="line">public ConcreteEdgesGraph() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Assert-断言）"><a href="#Assert-断言）" class="headerlink" title="Assert (断言）"></a>Assert (断言）</h1><p>&emsp;(1)<code>assert [boolean表达式]</code><br><br>&emsp;&emsp;如果表达式为true,程序继续执行，若为false则抛出AssertionError，并终止执行。<br><br>&emsp;(2)<code>assert [boolean 表达式:错误表达式(日志)]</code><br><br>&emsp;&emsp;如果表达式为true，程序继续执行。如果为false，则程序抛出java.lang.AssertionError，输出[错误信息]。</p><h1 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h1><p>&emsp;就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。详见<a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener">迭代器</a><br><br>而对应于SC实验中，对边的遍历涉及到迭代器的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Edge&gt; iteratorEdges = new ArrayList&lt;Edge&gt;(edges);</span><br><span class="line">    for(Edge i : iteratorEdges) &#123;</span><br><span class="line">    if(i.getSource().equals(vertex) || i.getTarget().equals(vertex))</span><br><span class="line">    edges.remove(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>简而言之就是可以存在这个东西，如果没有此声明的话会出错-没有实例化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final String label;</span><br><span class="line">private final Map&lt;String, Integer&gt; toVertex;  //声明存在合法变量</span><br></pre></td></tr></table></figure></p><p>对应于以下的实例化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toVertex = new HashMap&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>&emsp;Java泛型（generics）是JDK5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许程序员在编译时检测到非法的类型。<br>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br><br>&emsp;在软件工程课程里面<a href="http://web.mit.edu/6.031/www/sp17/psets/ps2/" target="_blank" rel="noopener">Poetic Walks</a>P3应用到了泛型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Vertex&lt;L&gt; &#123;</span><br><span class="line"> private final L label;</span><br><span class="line">    private final Map&lt;L, Integer&gt; toVertex;  //声明存在合法变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;Lab2的要求看得我一头雾水，又是接口又是不变量的，往日中学时代被老师手把手教的日子果真一去不复返了,不过这种大学的学习方式可能更接近于以后人生中的独自上下求索的艰辛历程吧……
    
    </summary>
    
      <category term="笔记" scheme="shawnsyx.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="shawnsyx.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SC_Lab2和Chapter3</title>
    <link href="shawnsyx.top/2019/03/19/SC%E5%AE%9E%E9%AA%8C%E4%BA%8C&amp;%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>shawnsyx.top/2019/03/19/SC实验二&amp;第三章/</id>
    <published>2019-03-19T13:23:45.000Z</published>
    <updated>2019-04-01T00:51:53.173Z</updated>
    
    <content type="html"><![CDATA[<p>  阅读材料来自于MIT的Software Construction课程 <a href="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/" target="_blank" rel="noopener">Reading 11: Abstraction Functions &amp; Rep Invariants</a>.<br><br>要点如下:<a id="more"></a><br><br>·<strong>invariant</strong><br><br>·<strong>representation exposure</strong><br><br>·<strong>abstraction functions</strong><br><br>·<strong>representation invariants</strong><br><br>The rep invariant will make it easier to catch bugs caused by a corrupted data structure.</p><h1 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h1><p>&emsp;一个好的抽象数据型(ADT)的关键：能否<strong>preserves its own invariants</strong></p><h2 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h2><p>&emsp;看下面的例子<br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String author;</span><br><span class="line"><span class="keyword">public</span> String text;</span><br><span class="line"><span class="keyword">public</span> Date timestamp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a Tweet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> author    Twitter user who wrote the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text      text of the tweet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timestamp date/time when the tweet was sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;  如何确保<code>Tweet</code>类是不可变的呢？即一旦建立，相关属性不改变。<br><br>&emsp;威胁之一是客户端能够直接修改这个域。Representation exposure ：code outside the class can modify the representation directly.<br><br>&emsp;<br>不过辛亏有<code>private</code>和<code>final</code>，官方给出如下解释</p><blockquote><p>The private and public keywords indicate which fields and methods are accessible only within the class and which can be accessed from outside the class. The final keyword also helps by guaranteeing that the fields of this immutable type won’t be reassigned after the object is constructed.</p></blockquote><p><br>&emsp;一种策略就是<strong>防御式拷贝(defensive copying)</strong>。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;值得注意的是，另一种copy a mutable object is clone(),但是有些问题，暂且不谈。<br><br><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return</span> a list of 24 inspiring tweets, one per hour today */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Tweet&gt; <span class="title">tweetEveryHourToday</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;Tweet&gt; list = <span class="keyword">new</span> ArrayList&lt;Tweet&gt;(); </span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line">       date.setHours(i);</span><br><span class="line">       list.add(<span class="keyword">new</span> Tweet(<span class="string">"rbmllr"</span>, <span class="string">"keep it up! you can do it"</span>, date));</span><br><span class="line">   &#125; </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/tweetEveryHourToday.png" alt><br><br>&emsp;所以不变性又被破坏了，采用一下策略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.timestamp = <span class="keyword">new</span> Date(timestamp.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Immutable-wrappers-around-mutable-data-types"><a href="#Immutable-wrappers-around-mutable-data-types" class="headerlink" title="Immutable wrappers around mutable data types"></a>Immutable wrappers around mutable data types</h2><p>&emsp;此时，轮到我们的<code>Collections.unmodifiableList()</code>亮相。但是一个downside就是得到的所谓的immutability只是在runtime，but not at compile time. Java也不会在你试着<code>sort()</code>这个unmodifiable list的时候警告你，反而抛给你一个冷冰冰的异常。<br><br>&emsp;注意阅读练习里面的array相关的problem</p><h1 id="Rep-invariant-and-abstraction-function"><a href="#Rep-invariant-and-abstraction-function" class="headerlink" title="Rep invariant and abstraction function"></a>Rep invariant and abstraction function</h1><p>&emsp;关键不仅仅在于选取两个集合Space，而且在于选取什么的元素为合法，并且怎样将它们对应成抽象的值。</p><blockquote><p>not only choosing the two spaces… but also deciding which rep values are legal, and how to interpret them as abstract values.</p></blockquote><p>比如根据此图，我们得到下面的映射：<img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/charset-af-ri.svg" alt><br>以下要点：<br><br>&emsp;<strong>·每一个抽象类都对应有原象</strong><br><br>&emsp;<strong>·一些抽象类映射前的原象不止一个</strong><br><br>&emsp;<strong>·而在集合R中并非所有元素都有映射的象</strong><br><br>&emsp;和实验相关一点，AF就是某个成员变量代表的抽象概念，RI就是对这个成员变量的限制。然而我这个傻子恍然大悟，AF就是”Abstraction functioin”,RI即为” Representation invariant”啊！！！</p><blockquote><p><strong>抽象函数AF</strong>：R和A之间映射关系的函数，即如何去解 释R中的每一个值为A中的每一个值。<br><br><strong>表示不变性RI</strong>：某个具体的“表示”是否是“合法的”<br><br>&emsp;可将RI看作：所有表示值的一个子集，包含了所有合法的表示值<br><br> &emsp;也可将RI看作：一个条件，描述了什么是“合法”的表示</p></blockquote><p><br>&emsp;从rep values到其所表示的抽象值之间的映射表示如下</p><blockquote><p>AF: R -&gt; A</p></blockquote><p> 同时也可以用<code>R → Boolean</code>的映射表示是否rep value和一个abstract values之间存在着对应关系。如下图所示<br><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/charset-norepeats.svg" alt><br>&emsp;对于表达值（rep value）而言， RI(r) 为真当且仅当r被AF映射。RI(“a”) = true, RI(“ac”) = true, 并且 RI(“acb”) = true, 但 RI(“aa”) = false and RI(“abbc”) = false.<br><br>&emsp;尽管有着不相同类型的rep value space 和相同的rep invariant，我们可以构建出不同的映射。例如“acgg”表示字符串之间的范围，[a-c]和[g-g]，所以代表的元素是集合set{a,b,c,g}.<br><br>&emsp;对于client of an abstract data type而言，visible and documented的应该为：abstract value space, creators, observes. 而不可见：abstraction function, rep 和 rep invariant.</p><blockquote><p>Rep invariant is a function from rep values to boolean.</p></blockquote><h2 id="Checkint-the-rep-invariant"><a href="#Checkint-the-rep-invariant" class="headerlink" title="Checkint the rep invariant"></a>Checkint the rep invariant</h2><p>check的特点：</p><blockquote><p>&emsp;It’s good for an implementer to call <code>checkRep()</code> just before returning from a public method of an ADT class.<br><br>&emsp;<code>checkRep()</code> asserts the rep invariant.</p></blockquote><h2 id="No-null-values-in-the-rep"><a href="#No-null-values-in-the-rep" class="headerlink" title="No null values in the rep"></a>No null values in the rep</h2><h2 id="Beneficnet-mutation"><a href="#Beneficnet-mutation" class="headerlink" title="Beneficnet mutation"></a>Beneficnet mutation</h2><h1 id="Documenting-the-AF-RI-and-safety-from-rep-exposure"><a href="#Documenting-the-AF-RI-and-safety-from-rep-exposure" class="headerlink" title="Documenting the AF,RI, and safety from rep exposure"></a>Documenting the AF,RI, and safety from rep exposure</h1><p>注意，在描述rep invariant and abstraction function的时候，必须注意：<br><br>&emsp;不能仅仅用“域内全员合法”来简简单单概括RI，重要的是explain是如何区分“合法”和“非法”的。<br><br>&emsp;同样的，对于AF而言，仅仅声明“represents a set of charaters”也是不够的。而应该<strong>define precisely how the concrete field values are interpreted</strong><br>而根据<a href="http://https://blog.csdn.net/weixin_39643135/article/details/80231152" target="_blank" rel="noopener">同学的解释</a></p><blockquote><p><strong>Rep exposure</strong>：<br><br>&emsp;java中数据类型分为mutable和immutable的，对前者进行的操作可能会改变其内部数据；而对后者的操作不改变其内部值，而是构造新的对象。因此，对于mutable的数据，如果没有良好的保护，意味着client对其的调用可以直接修改内部数据。</p></blockquote><h3 id="What-an-ADT-specification-may-talk-about"><a href="#What-an-ADT-specification-may-talk-about" class="headerlink" title="What an ADT specification may talk about"></a>What an ADT specification may talk about</h3><p><img src="http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/figures/adt-firewall.svg" alt><br><br></p><h1 id="ADT-invariants-replace-preconditions"><a href="#ADT-invariants-replace-preconditions" class="headerlink" title="ADT invariants replace preconditions"></a>ADT invariants replace preconditions</h1><p>An invariant is a property of a program that is always true, for every possible runtime state of the program.<br><br>&emsp;为什么需要不变量？ <del>因为爱情。</del>保持程序的“正确性”，容易发现错误。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="SPEC"><a href="#SPEC" class="headerlink" title="SPEC"></a>SPEC</h2><p>&emsp;SPEC is the abbreviation of the word-specification，规约。client能干什么，不能干什么，输入输出满足的条件将在spec中罗列得清清楚楚。<br>大致要点</p><ol><li>Function / method in programming language</li><li>Specification: Programming for communication </li><li>Designing specifications<br><br><h3 id="Spec-Structure"><a href="#Spec-Structure" class="headerlink" title="Spec Structure"></a>Spec Structure</h3></li></ol><ul><li>前置条件 precondition(对客户端的约束，在使用方法时必须满足的条件）<blockquote><p>The precondition is an obligation on the client (i.e., the caller of the method). It’s a condition over the state in which the method is invoked. </p></blockquote></li></ul><ul><li><p>后置条件 postcondition(后置条件：对开发者的约束，方法结束时必须满足的条件)</p><blockquote><p>The postcondition is an obligation on the implementer of the method.  </p></blockquote></li><li><p>– Precondition , indicated by the keyword <strong>requires</strong><br><br>– Postcondition , indicated by the keyword <strong>effects</strong><br><br>相应于<code>@return</code>和<code>@param</code>呢？来看课件讲义：<br><br>&emsp;Parameters are described by <strong>@param</strong> clauses and results are described by @return and <strong>@throws</strong> clauses.<br><br>&emsp;Put the preconditions into <strong>@param</strong> where possible, and postconditions into <strong>@return</strong> and <strong>@throws</strong>.<br><br></p><h3 id="规约强弱？"><a href="#规约强弱？" class="headerlink" title="规约强弱？"></a>规约强弱？</h3><p><br>&emsp;规约的强度S2&gt;=S1 A specification S2 is stronger than or equal to a specification S1 if </p></li><li>S2’s precondition is weaker than or equal to S1’s  前置条件更弱 </li><li>S2’s postcondition is stronger than or equal to S1’s, for the states that satisfy S1’s precondition. 后置条件更强<br><br>&emsp;简而言之，spec变强就是<strong>更放松的前置条件</strong> + <strong>更严格的后置条件</strong> </li></ul><h1 id="漫漫实验路"><a href="#漫漫实验路" class="headerlink" title="漫漫实验路"></a>漫漫实验路</h1><h2 id="ea"><a href="#ea" class="headerlink" title="-ea"></a>-ea</h2><p>&emsp;多谢橙子的提醒，在poet测试里面需要用到assert断言，而必须要在Eclipse中开启assert选项。<a href="https://blog.csdn.net/styshoo/article/details/48209493" target="_blank" rel="noopener">详情</a></p><blockquote><p>Windows -&gt; Preferences -&gt;Java -&gt;Installed JREs -&gt;待使用的JDK -&gt;Edit -&gt;Default VM Arguments文本框中输入:-ea</p></blockquote><h1 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h1><h2 id="区分override-和-overload"><a href="#区分override-和-overload" class="headerlink" title="区分override 和 overload"></a>区分override 和 overload</h2><p>&emsp;overload用同一个方法名字但是输入不同的参数列表，比如本人在实验中构造的函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(L source,L target, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">label = source;</span><br><span class="line">    toVertex = <span class="keyword">new</span> HashMap&lt;L, Integer&gt;();</span><br><span class="line">toVertex.put(target, weight);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(L name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.label = name;</span><br><span class="line"><span class="keyword">this</span>.toVertex = <span class="keyword">new</span> HashMap&lt;L, Integer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;此外override在run time检查，而overload是在compile阶段就进行检查</p><h1 id="3-5-Equality-in-ADT-and-OOP"><a href="#3-5-Equality-in-ADT-and-OOP" class="headerlink" title="3.5 Equality in ADT and OOP"></a>3.5 Equality in ADT and OOP</h1><h2 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a>Equality</h2><p>&emsp;等价关系(Equivalence Relation)：自反、对称、传递</p><h3 id="Equality-in-immutable-types"><a href="#Equality-in-immutable-types" class="headerlink" title="Equality in immutable types"></a>Equality in immutable types</h3><ol><li><strong>a equals b if and only if f(a) = f(b)</strong>，即AF映射同样的结果。</li><li>站在外部角度，对两个对象调用任何相同操作，都能得到相同结果，认为等价性成立。<br>举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Duration &#123;</span><br><span class="line">    private final int mins;</span><br><span class="line">    private final int secs;</span><br><span class="line">    // Rep invariant:</span><br><span class="line">    //    mins &gt;= 0, secs &gt;= 0</span><br><span class="line">    // Abstraction function:</span><br><span class="line">    //    AF(min, secs) = the span of time of mins minutes and secs seconds</span><br><span class="line"></span><br><span class="line">    /** Make a duration lasting for m minutes and s seconds. */</span><br><span class="line">    public Duration(int m, int s) &#123;</span><br><span class="line">        mins = m; secs = s;</span><br><span class="line">    &#125;</span><br><span class="line">    /** @return length of this duration in seconds */</span><br><span class="line">    public long getLength() &#123;</span><br><span class="line">        return mins*60 + secs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中下列那些等价呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = new Duration (1, 2);</span><br><span class="line">Duration d2 = new Duration (1, 3);</span><br><span class="line">Duration d3 = new Duration (0, 62);</span><br><span class="line">Duration d4 = new Duration (1, 2);</span><br></pre></td></tr></table></figure></p><h2 id="区分equals和“-”"><a href="#区分equals和“-”" class="headerlink" title="区分equals和“==”"></a>区分equals和“==”</h2><p>&emsp;等价性：引用等价性和对象等价性</p><p>&emsp;对基本数据类型，使用<strong>==</strong>判定相等</p><p>&emsp;对对象类型，使用equals.</p><ul><li>== 和内存空间相关。</li></ul><p>再看这个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span> </span>&#123;</span><br><span class="line">    ...   </span><br><span class="line">    <span class="comment">// Problematic definition of equals()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Duration that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getLength() == that.getLength();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Duration d1 = <span class="keyword">new</span> Duration (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Duration d2 = <span class="keyword">new</span> Duration (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Object o2 = d2;</span><br><span class="line">d1.equals(d2) → <span class="keyword">true</span></span><br><span class="line">d1.equals(o2) → <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>&emsp;答案为true和false。d2的类型是Duration，而o2的类型是Object，在类Duration里面的equals无法对这个o2进行等价判断。而且o2和d1指向并非同一内存空间，因此会返回<strong>false</strong>。</p><p>&emsp;上述给的例子是overload而非override。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Duration extends Object &#123;</span><br><span class="line">    // explicit method that we declared:</span><br><span class="line">    public boolean equals(Duration that) &#123;</span><br><span class="line">        return this.getLength() == that.getLength();</span><br><span class="line">    &#125;</span><br><span class="line">    // implicit method inherited from Object:</span><br><span class="line">    public boolean equals(Object that) &#123;</span><br><span class="line">        return this == that;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;equals三件套：（1）是否为空 （2）类型是否相同 （3）根据AF设计相等判断。但是有一弊处：在没有AF情况下判断每个域的等价性，这是不合理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  阅读材料来自于MIT的Software Construction课程 &lt;a href=&quot;http://web.mit.edu/6.031/www/sp18/classes/11-abstraction-functions-rep-invariants/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reading 11: Abstraction Functions &amp;amp; Rep Invariants&lt;/a&gt;.&lt;br&gt;&lt;br&gt;要点如下:
    
    </summary>
    
      <category term="软件构造笔记" scheme="shawnsyx.top/categories/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件构造笔记" scheme="shawnsyx.top/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>鄙人胡诌</title>
    <link href="shawnsyx.top/2019/03/19/%E9%84%99%E4%BA%BA%E6%9D%82%E8%B0%88/"/>
    <id>shawnsyx.top/2019/03/19/鄙人杂谈/</id>
    <published>2019-03-19T10:47:46.000Z</published>
    <updated>2019-03-24T11:18:24.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  自修自持莫道此间非彼岸，即心即佛须知东土是西天</p></blockquote><hr><p> &ensp; 羡艳着橙子和钟哥的博客，自己也心痒痒，谁所菜鸡不能有自己的鸡笼？于是乎我也按着教程一步一步地de着bug，学着毫无技术含量的操作。<br><br><br>&ensp;或许写博客当有中学时代拿着尺子和铅笔一点点打格整理笔记的美感？我挺喜欢手字笔录的方式，但怎奈这越学越深的计算机世界不给你手字笔录的时间让你横平竖直工笔正楷地整理笔记。<br><br><br>&ensp;《离骚》中有“朝濯发于汤谷兮，夕晞余身兮九阳”，闭目仿佛看见一身高八尺有余形貌昳丽的长发美男于光中背对着你，可瞅瞅我现在满脸油光，痘印未消，面如土色，发型凌乱，眼小无神，体形消瘦······（再说下去我都把我自己说抑郁了）。美男这辈子估计是够呛，或许找个颜值高点的妹子改良基因后能让我儿子当上美男就不错了，我再努努力当上富二代他爹？<br><br><br>&ensp; 一点一点走吧，搭这个博客的时候曾经一度想放弃，为什么那么多的错？那么多的异常？<br><br><br>&ensp; 但是爹一直反对我做事三分钟热度或者半途而废。秉着“吾乃光宗耀祖之孙氏”的信念，忍着不挤额头上痘痘的冲动，我耐着性子开始了以后的博客之路。不过也好，有个能够宣泄的方寸之地······<br><br><br>&ensp; “是非曲吉祥物”是我和发小一块玩梦幻西游取的第一个人物名字，剑侠客-大唐官府。十多年来，人们走的走，留的留，自己也从任性妄为到忍耐包容的路上自修自持。有些事能够想，有些事只能放，放下那无奈不甘的执念吧。<br><br><br>&ensp; 完善阿里云的信息时跳出密保问题，“你儿时最好的伙伴”，我不假思索地填上cq，可是我们好久好久都没见面了，甚至好久好久都没有说过话了，我们仅存的联系方式就剩下了QQ，我搬了家，他去了外地。但是想一想，人生哪有这么多时间给你感慨呢？孤独的不仅仅是孤单的一人，还有那秋风乍起时望着万家灯火而独自彳亍的异乡客。<br><br><br>&ensp;不过当个风筝也是好的，虽被一线束缚起来，总不至于落得无处可归，总有人惦记着你，牵扯着你，不肯松手。<br><br><br>&ensp;可能是经历了一些事吧，我最近竟能在看似千篇一律的生活中活出一瞬间的“幸福感”：雏菊的花又开了些，托福听力又能多听懂些叽里呱啦的词了，洗澡的水温舒服了些······也忘了在哪抄的的这些：<br><br></p><blockquote><p>你为什么会爱上人类？他们没有永生，脆弱而匆忙<br><br>  &ensp;&ensp;就因为他们没有永生，害怕死亡，才有那么脆弱和匆忙。我爱上的是那脆弱中的争取和躁动，我爱上的是那随时会失去的短暂和恐慌。</p></blockquote><p>&ensp;穷且意坚，不堕青云之志。当自强，于人生路上不忘克己复礼。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;  自修自持莫道此间非彼岸，即心即佛须知东土是西天&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt; &amp;ensp; 羡艳着橙子和钟哥的博客，自己也心痒痒，谁所菜鸡不能有自己的鸡笼？于是乎我也按着教程一步一步地de着bug，学着毫无技术含量的操作
      
    
    </summary>
    
      <category term="竹林深处" scheme="shawnsyx.top/categories/%E7%AB%B9%E6%9E%97%E6%B7%B1%E5%A4%84/"/>
    
    
      <category term="竹林深处" scheme="shawnsyx.top/tags/%E7%AB%B9%E6%9E%97%E6%B7%B1%E5%A4%84/"/>
    
  </entry>
  
</feed>
